/*
Generated by LwipMibCompiler
*/

#include "lwip/apps/snmp_opts.h"
#if LWIP_SNMP

#include "upsPrivateMIB.h"
//#include "DatabaseHandler.h"
#include "UPSInterface.h"

/* --- upsInput 1.3.6.1.4.1.21111.1.1.4 ----------------------------------------------------- */

static const struct snmp_scalar_node upsinlinebads_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(1, SNMP_ASN1_TYPE_INTEGER, upsinput_treenode_get_value);

static const struct snmp_scalar_node upsinttlapparentpower_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(2, SNMP_ASN1_TYPE_INTEGER, upsinput_treenode_get_value);

static const struct snmp_scalar_node upsinttltruepower_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(3, SNMP_ASN1_TYPE_INTEGER, upsinput_treenode_get_value);

static const struct snmp_scalar_node upsinnumlines_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(4, SNMP_ASN1_TYPE_INTEGER, upsinput_treenode_get_value);

static const struct snmp_table_col_def upsintable_columns[] = {
  {1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsInLineIndex */ 
  {2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsInFrequency */ 
  {3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsInVoltage */ 
  {4, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsInCurrent */ 
  {5, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsInApparentPower */ 
  {6, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsInTruePower */ 
  {7, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsInPowerFactor */ 
  {8, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsInLineVoltage */ 
};
static const struct snmp_table_node upsintable = SNMP_TABLE_CREATE(5, upsintable_columns, upsintable_get_instance, upsintable_get_next_instance, upsintable_get_value, NULL, NULL);

static const struct snmp_scalar_node upsinttlvoltage_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(6, SNMP_ASN1_TYPE_INTEGER, upsinput_treenode_get_value);

static const struct snmp_scalar_node upsinttlcurrent_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(7, SNMP_ASN1_TYPE_INTEGER, upsinput_treenode_get_value);

static const struct snmp_node *const upsinput_subnodes[] = {
  &upsinlinebads_scalar.node.node,
  &upsinttlapparentpower_scalar.node.node,
  &upsinttltruepower_scalar.node.node,
  &upsinnumlines_scalar.node.node,
  &upsintable.node.node,
  &upsinttlvoltage_scalar.node.node,
  &upsinttlcurrent_scalar.node.node
};
static const struct snmp_tree_node upsinput_treenode = SNMP_CREATE_TREE_NODE(4, upsinput_subnodes);

/* --- upsOutput 1.3.6.1.4.1.21111.1.1.5 ----------------------------------------------------- */
static const struct snmp_scalar_node upsoutsource_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(1, SNMP_ASN1_TYPE_INTEGER, upsoutput_treenode_get_value);

static const struct snmp_scalar_node upsoutfrequency_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(2, SNMP_ASN1_TYPE_INTEGER, upsoutput_treenode_get_value);

static const struct snmp_scalar_node upsoutttlapparentpower_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(3, SNMP_ASN1_TYPE_INTEGER, upsoutput_treenode_get_value);

static const struct snmp_scalar_node upsoutttltruepower_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(4, SNMP_ASN1_TYPE_INTEGER, upsoutput_treenode_get_value);

static const struct snmp_scalar_node upsoutttlpercentload_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(5, SNMP_ASN1_TYPE_INTEGER, upsoutput_treenode_get_value);

static const struct snmp_scalar_node upsoutnumlines_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(6, SNMP_ASN1_TYPE_INTEGER, upsoutput_treenode_get_value);

static const struct snmp_table_col_def upsouttable_columns[] = {
  {1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsOutLineIndex */ 
  {2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsOutVoltage */ 
  {3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsOutCurrent */ 
  {4, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsOutApparentPower */ 
  {5, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsOutTruePower */ 
  {6, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsOutPowerFactor */ 
  {7, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsOutPercentLoad */ 
  {8, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsOutLineVoltage */ 
  {9, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsOutFrequency */ 
};
static const struct snmp_table_node upsouttable = SNMP_TABLE_CREATE(7, upsouttable_columns, upsouttable_get_instance, upsouttable_get_next_instance, upsouttable_get_value, NULL, NULL);

static const struct snmp_scalar_node upsoutttlvoltage_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(8, SNMP_ASN1_TYPE_INTEGER, upsoutput_treenode_get_value);

static const struct snmp_scalar_node upsoutttlcurrent_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(9, SNMP_ASN1_TYPE_INTEGER, upsoutput_treenode_get_value);

static const struct snmp_scalar_node upsoutstatus_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(10, SNMP_ASN1_TYPE_OCTET_STRING, upsoutput_treenode_get_value);

static const struct snmp_scalar_node upsoutsource2_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(11, SNMP_ASN1_TYPE_INTEGER, upsoutput_treenode_get_value);

static const struct snmp_node *const upsoutput_subnodes[] = {
  &upsoutsource_scalar.node.node,
  &upsoutfrequency_scalar.node.node,
  &upsoutttlapparentpower_scalar.node.node,
  &upsoutttltruepower_scalar.node.node,
  &upsoutttlpercentload_scalar.node.node,
  &upsoutnumlines_scalar.node.node,
  &upsouttable.node.node,
  &upsoutttlvoltage_scalar.node.node,
  &upsoutttlcurrent_scalar.node.node,
  &upsoutstatus_scalar.node.node,
  &upsoutsource2_scalar.node.node
};
static const struct snmp_tree_node upsoutput_treenode = SNMP_CREATE_TREE_NODE(5, upsoutput_subnodes);

/* --- upsBypass 1.3.6.1.4.1.21111.1.1.6 ----------------------------------------------------- */
static const struct snmp_scalar_node upsbyfrequency_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(1, SNMP_ASN1_TYPE_INTEGER, upsbypass_treenode_get_value);

static const struct snmp_scalar_node upsbynumlines_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(2, SNMP_ASN1_TYPE_INTEGER, upsbypass_treenode_get_value);

static const struct snmp_table_col_def upsbytable_columns[] = {
  {1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsByLineIndex */ 
  {2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsByVoltage */ 
  {3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsByCurrent */ 
  {4, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsByPower */ 
  {5, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsByLineVoltage */ 
};
static const struct snmp_table_node upsbytable = SNMP_TABLE_CREATE(3, upsbytable_columns, upsbytable_get_instance, upsbytable_get_next_instance, upsbytable_get_value, NULL, NULL);

static const struct snmp_node *const upsbypass_subnodes[] = {
  &upsbyfrequency_scalar.node.node,
  &upsbynumlines_scalar.node.node,
  &upsbytable.node.node
};
static const struct snmp_tree_node upsbypass_treenode = SNMP_CREATE_TREE_NODE(6, upsbypass_subnodes);

/* --- ups 1.3.6.1.4.1.21111.1.1 ----------------------------------------------------- */
static const struct snmp_scalar_array_node_def upsident_scalars_nodes[] = {
  {1, SNMP_ASN1_TYPE_OCTET_STRING, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsIdManufacturer */ 
  {2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsIdProtocol */ 
  {3, SNMP_ASN1_TYPE_OCTET_STRING, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsIdModelName */ 
  {4, SNMP_ASN1_TYPE_OCTET_STRING, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsIdSerialNumber */ 
  {5, SNMP_ASN1_TYPE_OCTET_STRING, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsIdName */ 
  {6, SNMP_ASN1_TYPE_OCTET_STRING, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsIdFWVersion */ 
  {7, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsIdUPSType */ 
};
static const struct snmp_scalar_array_node upsident_scalars = SNMP_SCALAR_CREATE_ARRAY_NODE(1, upsident_scalars_nodes, upsident_scalars_get_value, upsident_scalars_set_test, upsident_scalars_set_value);

static const struct snmp_scalar_array_node_def upsrating_scalars_nodes[] = {
  {1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsRatinVoltage */ 
  {2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsRatoutVoltage */ 
  {3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsRatoutFrequency */ 
  {4, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsRatoutCurrent */ 
  {5, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsRatoutApparentPower */ 
  {6, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsRatoutTruePower */ 
  {7, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsRatBatVoltage */ 
};
static const struct snmp_scalar_array_node upsrating_scalars = SNMP_SCALAR_CREATE_ARRAY_NODE(2, upsrating_scalars_nodes, upsrating_scalars_get_value, NULL, NULL);

static const struct snmp_scalar_array_node_def upsbattery_scalars_nodes[] = {
  {1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatStatus */ 
  {2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatSecondsOnBattery */ 
  {3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatEstMinutesRemaining */ 
  {4, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatEstChargeRemaining */ 
  {5, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatPBatVoltage */ 
  {6, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatNBatVoltage */ 
  {7, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatPBatCurrent */ 
  {8, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatNBatCurrent */ 
  {9, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatPBatChargCurrent */ 
  {10, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatNBatchargCurrent */ 
  {11, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatPBatDischargCurrent */ 
  {12, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatNBatDischargCurrent */ 
  {13, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatTemperature */ 
  {14, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatNumberInSeries */ 
  {15, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatNumberInParallel */ 
  {16, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatPBatDischargCurrent2 */ 
};
static const struct snmp_scalar_array_node upsbattery_scalars = SNMP_SCALAR_CREATE_ARRAY_NODE(3, upsbattery_scalars_nodes, upsbattery_scalars_get_value, NULL, NULL);

static const struct snmp_scalar_array_node_def upstest_scalars_nodes[] = {
  {1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsTstBatteryTest */ 
  {2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsTstBatteryTestResult */ 
  {3, SNMP_ASN1_TYPE_OCTET_STRING, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsTstBatteryTestStartTime */ 
  {4, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsTstBatterySettingTime */ 
};
static const struct snmp_scalar_array_node upstest_scalars = SNMP_SCALAR_CREATE_ARRAY_NODE(7, upstest_scalars_nodes, upstest_scalars_get_value, upstest_scalars_set_test, upstest_scalars_set_value);

static const struct snmp_scalar_array_node_def upscontrol_scalars_nodes[] = {
  {1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCtlShutdownDelay */ 
  {2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCtlSleepTime */ 
  {3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCtlStartupAfterDelay */ 
  {4, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCtlbuzzer */ 
  {5, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCtlRemoteControlUPS */ 
  {6, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCtloutletPoweron */ 
  {7, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCtloutletPoweroff */ 
  {8, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCtlOutlet1Powerofftime */ 
  {9, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCtlOutlet2Powerofftime */ 
  {10, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCtlResetConfigure */ 
};
static const struct snmp_scalar_array_node upscontrol_scalars = SNMP_SCALAR_CREATE_ARRAY_NODE(8, upscontrol_scalars_nodes, upscontrol_scalars_get_value, upscontrol_scalars_set_test, upscontrol_scalars_set_value);

static const struct snmp_scalar_array_node_def agentconfig_scalars_nodes[] = {
  {1, SNMP_ASN1_TYPE_OCTET_STRING, SNMP_NODE_INSTANCE_READ_WRITE}, /* agentConfigDatetime */ 
};
static const struct snmp_scalar_array_node agentconfig_scalars = SNMP_SCALAR_CREATE_ARRAY_NODE(9, agentconfig_scalars_nodes, agentconfig_scalars_get_value, agentconfig_scalars_set_test, agentconfig_scalars_set_value);

static const struct snmp_scalar_array_node_def commconfig_scalars_nodes[] = {
  {1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* commBaudRate */ 
  {2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* commDatabits */ 
  {3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* commStopbits */ 
  {4, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* commParity */ 
  {5, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* commTimeout */ 
};
static const struct snmp_scalar_array_node commconfig_scalars = SNMP_SCALAR_CREATE_ARRAY_NODE(10, commconfig_scalars_nodes, commconfig_scalars_get_value, commconfig_scalars_set_test, commconfig_scalars_set_value);

static const struct snmp_scalar_array_node_def upsconfig_scalars_nodes[] = {
  {1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgAlarmbypass */ 
  {2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgAlarmbattery */ 
  {3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgAutoReboot */ 
  {4, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgBypasswhenupsoff */ 
  {5, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgBatterDDP */ 
  {6, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgConvertermode */ 
  {7, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgECOmode */ 
  {8, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgAdvanceECOmode */ 
  {9, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgGreenPowerFunction */ 
  {10, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgBatteryOSC */ 
  {11, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgAllowShort3times */ 
  {12, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgColdstart */ 
  {13, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgBypassNotAllowed */ 
  {14, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgBatterylowprotect */ 
  {15, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgP1progoutletcontrol */ 
  {16, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgP2progoutletcontrol */ 
  {17, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgInverterShortClear */ 
  {18, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgSitefaildetection */ 
  {19, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgBatNumInParallel */ 
  {20, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgBatNumInSeries */ 
  {21, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgBypassmaxvoltage */ 
  {22, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgBypassminvoltage */ 
  {23, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgBypassmaxfrequency */ 
  {24, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgBypassminfrequency */ 
  {25, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgECOmaxvoltage */ 
  {26, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgECOminvoltage */ 
  {27, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgFreeRunMaxFrequency */ 
  {28, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgFreeRunMinFrequency */ 
  {29, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsCfgEPOStatus */ 
  {30, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsCfgQSK1Status */ 
  {31, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsCfgQSK2Status */ 
  {32, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsCfgQSKT1Delaytime */ 
  {33, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsCfgQSKT2Delaytime */ 
  {34, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgConstantPhaseAngle */ 
  {35, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsCfgInPhaseAngle */ 
  {36, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgOutPhaseAngle */ 
  {37, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgLimiRunOnBatMode */ 
  {38, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsCfgChargingCurrent */ 
  {39, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgBatSeftCheckVolt */ 
  {40, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgOverChargVolt */ 
  {41, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgBattUnderVolt */ 
  {42, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgBattLowVolt */ 
  {43, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgIn1VoltHLoss */ 
  {44, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgIn1VoltLLoss */ 
  {45, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgIn2VoltHLoss */ 
  {46, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgIn2VoltLLoss */ 
  {47, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsCfgBatteryTurnOn */ 
};
static const struct snmp_scalar_array_node upsconfig_scalars = SNMP_SCALAR_CREATE_ARRAY_NODE(11, upsconfig_scalars_nodes, upsconfig_scalars_get_value, upsconfig_scalars_set_test, upsconfig_scalars_set_value);

static const struct snmp_scalar_array_node_def extend_scalars_nodes[] = {
  {1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* extendWorkTemperature */ 
  {2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* extendWorkhumidity */ 
  {3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* extendSmokeScope */ 
  {4, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* extendEMDAlarm1 */ 
  {5, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* extendEMDAlarm2 */ 
  {6, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* extendEMDAlarm3 */ 
  {7, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* extendEMDAlarm4 */ 
};
static const struct snmp_scalar_array_node extend_scalars = SNMP_SCALAR_CREATE_ARRAY_NODE(13, extend_scalars_nodes, extend_scalars_get_value, NULL, NULL);

static const struct snmp_node *const ups_subnodes[] = {
  &upsident_scalars.node.node,
  &upsrating_scalars.node.node,
  &upsbattery_scalars.node.node,
  &upsinput_treenode.node,
  &upsoutput_treenode.node,
  &upsbypass_treenode.node,
  &upstest_scalars.node.node,
  &upscontrol_scalars.node.node,
  &agentconfig_scalars.node.node,
  &commconfig_scalars.node.node,
  &upsconfig_scalars.node.node,
  &extend_scalars.node.node
};
static const struct snmp_tree_node ups_treenode = SNMP_CREATE_TREE_NODE(1, ups_subnodes);

/* --- products 1.3.6.1.4.1.21111.1 ----------------------------------------------------- */
static const struct snmp_node *const products_subnodes[] = {
  &ups_treenode.node
};
static const struct snmp_tree_node products_treenode = SNMP_CREATE_TREE_NODE(1, products_subnodes);

/* --- companyMIB  ----------------------------------------------------- */
static const struct snmp_node *const companymib_subnodes[] = {
  &products_treenode.node
};
static const struct snmp_tree_node companymib_root = SNMP_CREATE_TREE_NODE(21111, companymib_subnodes);
static const u32_t companymib_base_oid[] = {1, 3, 6, 1, 4, 1, 21111};
const struct snmp_mib companymib = {companymib_base_oid, LWIP_ARRAYSIZE(companymib_base_oid), &companymib_root.node};

/*
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LWIP MIB generator - preserved section begin
Code below is preserved on regeneration. Remove these comment lines to regenerate code.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*/

/* --- upsInput 1.3.6.1.4.1.21111.1.1.4 ----------------------------------------------------- */
snmp_err_t upsintable_get_instance(const u32_t *column, const u32_t *row_oid, u8_t row_oid_len, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    upsInLineIndex (Integer, OID length = 1)
   */
   snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

  // if ((row_oid_len > 0) && (row_oid_len > 0))
   if ((row_oid_len == 1) && (*column<=8))
   {
      LWIP_UNUSED_ARG(column);
      LWIP_UNUSED_ARG(row_oid);
      LWIP_UNUSED_ARG(cell_instance);
      /*
      TODO: check if 'row_oid'/'row_oid_len' params contain a valid instance oid for a row
      If so, set 'err = SNMP_ERR_NOERROR;'
      
      snmp_oid_* methods may be used for easier processing of oid
      
      In order to avoid decoding OID a second time in subsequent get_value/set_test/set_value methods,
      you may store an arbitrary value (like a pointer to target value object) in 'cell_instance->reference'/'cell_instance->reference_len'.
      But be aware that not always a subsequent method is called -> Do NOT allocate memory here and try to release it in subsequent methods!
      
      You also may replace function pointers in 'cell_instance' param for get/test/set methods which contain the default values from table definition,
      in order to provide special methods, for the currently processed cell. Changed pointers are only valid for current request.
      */
      err = SNMP_ERR_NOERROR;
   }
   return err;
}
snmp_err_t upsintable_get_next_instance(const u32_t *column, struct snmp_obj_id *row_oid, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    upsInLineIndex (Integer, OID length = 1)
   */
   u32_t columnValue=*column;
   snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

   LWIP_UNUSED_ARG(column);
   LWIP_UNUSED_ARG(row_oid);
   LWIP_UNUSED_ARG(cell_instance);

  if((columnValue <8) && (row_oid->len == 1))
  {
     columnValue+=1;
	 cell_instance->instance_oid.id[0]=1;
	 cell_instance->instance_oid.id[1]=columnValue;
     err = SNMP_ERR_NOERROR;
  }
  else if((columnValue <8) && (row_oid->len == 0))
  {
	 cell_instance->instance_oid.id[0]=1;
	 cell_instance->instance_oid.id[1]=columnValue;
	 row_oid->len=1;
	 row_oid->id[0]=0;
	 err = SNMP_ERR_NOERROR;
  }
  return err;
}
s16_t upsintable_get_value(struct snmp_node_instance *cell_instance, void *value)
{
   s16_t value_len;

   switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id))
   {
      case 1:
         {
            /* upsInLineIndex */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.supportedPhase.Bytes.InputPhase;

         }
         break;
      case 2:
         {
            /* upsInFrequency */
             s32_t *v = (s32_t *)value;
			 value_len = sizeof(s32_t);
			 *v=UPSDb.InputFreq;
         }
         break;
      case 3:
         {
            /* upsInVoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.InputVolt;
         }
         break;
      case 4:
         {
            /* upsInCurrent */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=0;
             LWIP_UNUSED_ARG(v);
         }
         break;
      case 5:
         {
            /* upsInApparentPower */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=0;
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 6:
         {
            /* upsInTruePower */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=0;
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 7:
         {
            /* upsInPowerFactor */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=0;
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 8:
         {
            /* upsInLineVoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=0;
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upsintable_get_value(): unknown id: %"S32_F"\n", SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
            value_len = 0;
         }
         break;
   }
   return value_len;
}

s16_t upsinput_treenode_get_value(struct snmp_node_instance *instance, void *value)
{
   s16_t value_len;

   switch (instance->node->oid)
   {
      case 1:
         {
            /* upsInLineBads */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 2:
         {
            /* upsInTtlApparentPower */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 3:
         {
            /* upsInTtlTruePower */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 4:
         {
            /* upsInNumLines */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.supportedPhase.Bytes.InputPhase;
         }
         break;
      case 6:
         {
            /* upsInTtlVoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.OutputVolt;
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 7:
         {
            /* upsInTtlCurrent */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.OutputCurr;
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upsinput_treenode_get_value(): unknown id: %"S32_F"\n", instance->node->oid));
            value_len = 0;
         }
         break;
   }
   return value_len;
}

/* --- upsOutput 1.3.6.1.4.1.21111.1.1.5 ----------------------------------------------------- */
snmp_err_t upsouttable_get_instance(const u32_t *column, const u32_t *row_oid, u8_t row_oid_len, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    upsOutLineIndex (Integer, OID length = 1)
   */
   snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

   if ((row_oid_len == 1) && (*column<=9))
   {
      LWIP_UNUSED_ARG(column);
      LWIP_UNUSED_ARG(row_oid);
      LWIP_UNUSED_ARG(cell_instance);
      /*
      TODO: check if 'row_oid'/'row_oid_len' params contain a valid instance oid for a row
      If so, set 'err = SNMP_ERR_NOERROR;'
      
      snmp_oid_* methods may be used for easier processing of oid
      
      In order to avoid decoding OID a second time in subsequent get_value/set_test/set_value methods,
      you may store an arbitrary value (like a pointer to target value object) in 'cell_instance->reference'/'cell_instance->reference_len'.
      But be aware that not always a subsequent method is called -> Do NOT allocate memory here and try to release it in subsequent methods!
      
      You also may replace function pointers in 'cell_instance' param for get/test/set methods which contain the default values from table definition,
      in order to provide special methods, for the currently processed cell. Changed pointers are only valid for current request.
      */
      err = SNMP_ERR_NOERROR;
   }
   return err;
}
snmp_err_t upsouttable_get_next_instance(const u32_t *column, struct snmp_obj_id *row_oid, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    upsOutLineIndex (Integer, OID length = 1)
   */
	 u32_t columnValue=*column;
	 snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;
	
	 LWIP_UNUSED_ARG(column);
	 LWIP_UNUSED_ARG(row_oid);
	 LWIP_UNUSED_ARG(cell_instance);
	
	if((columnValue <9) && (row_oid->len == 1))
	{
	   columnValue+=1;
	   cell_instance->instance_oid.id[0]=1;
	   cell_instance->instance_oid.id[1]=columnValue;
	   err = SNMP_ERR_NOERROR;
	}
	else if((columnValue <9) && (row_oid->len == 0))
	{
	   cell_instance->instance_oid.id[0]=1;
	   cell_instance->instance_oid.id[1]=columnValue;
	   row_oid->len=1;
	   row_oid->id[0]=0;
	   err = SNMP_ERR_NOERROR;
	}
	return err;

}
s16_t upsouttable_get_value(struct snmp_node_instance *cell_instance, void *value)
{
   s16_t value_len;

   switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id))
   {
      case 1:
         {
            /* upsOutLineIndex */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
           *v=UPSDb.supportedPhase.Bytes.OutputPhase;
         }
         break;
      case 2:
         {
            /* upsOutVoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.OutputVolt;
         }
         break;
      case 3:
         {
            /* upsOutCurrent */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.OutputCurr;
         }
         break;
      case 4:
         {
            /* upsOutApparentPower */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v = 0;
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 5:
         {
            /* upsOutTruePower */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v = 0;
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 6:
         {
            /* upsOutPowerFactor */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v = 0;
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 7:
         {
            /* upsOutPercentLoad */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.OutputLoadPercent;
         }
         break;
      case 8:
         {
            /* upsOutLineVoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v = 0;
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 9:
         {
            /* upsOutFrequency */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.OutputFreq;
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upsouttable_get_value(): unknown id: %"S32_F"\n", SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
            value_len = 0;
         }
         break;
   }
   return value_len;
}

s16_t upsoutput_treenode_get_value(struct snmp_node_instance *instance, void *value)
{
   s16_t value_len;

   switch (instance->node->oid)
   {
      case 1:
         {
            /* upsOutSource */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
           	if(UPSDb.UPSMode[0]=='P')//Power On Mode
            {
           	  *v=0;//Normal
            }				
			else if(UPSDb.UPSMode[0]=='S')//Standby Mode
            {
			    *v=1;//Other
            }		
            else if(UPSDb.UPSMode[0]=='Y')//Bypass Mode
            {
                *v=4;//Bypass
            }	
            else if(UPSDb.UPSMode[0]=='L')//Line Mode
            {
               *v=3;//Other
            }	
            else if(UPSDb.UPSMode[0]=='B')//Battery Mode
            {
                *v=5;//Battery Mode
            }			
            else if(UPSDb.UPSMode[0]=='T')//Battery test Mode
            {
				*v=8;//Battery test Mode
            }	
            else if(UPSDb.UPSMode[0]=='F')//Fault Mode
            {
				*v=9;//Fault Mode
            }
            else if(UPSDb.UPSMode[0]=='E')//HE/ECO Mode
            {
				*v=10;//HE/ECO Mode
            }
            else if(UPSDb.UPSMode[0]=='C')//Converter Mode
            {
				*v=8;//Converter Mode
            }
            else if(UPSDb.UPSMode[0]=='D')//Shutdown Mode
            {
				*v=1;//other
            }			
            else 
            {
				*v=2;//none
            }
         }
         break;
      case 2:
         {
            /* upsOutFrequency */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.OutputFreq;
         }
         break;
      case 3:
         {
            /* upsOutTtlApparentPower */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 4:
         {
            /* upsOutTtlTruePower */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 5:
         {
            /* upsOutTtlPercentLoad */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 6:
         {
            /* upsOutNumLines */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.supportedPhase.Bytes.OutputPhase;
         }
         break;
      case 8:
         {
            /* upsOutTtlVoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 9:
         {
            /* upsOutTtlCurrent */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 10:
         {
            /* upsOutStatus */
            u8_t *v = (u8_t *)value;

            /* TODO: take care that value with variable length fits into buffer: (value_len <= SNMP_MAX_VALUE_SIZE) */
            /* TODO: take care of len restrictions defined in MIB: (value_len == 4) */
            /* TODO: put requested value to '*v' here */
            value_len = 0;
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 11:
         {
            /* upsOutSource2 */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
           	if(UPSDb.UPSMode[0]=='P')//Power On Mode
            {
				*v=3;//Normal
            }				
			else if(UPSDb.UPSMode[0]=='S')//Standby Mode
            {
				*v=1;//Other
            }		
            else if(UPSDb.UPSMode[0]=='Y')//Bypass Mode
            {
				*v=4;//Bypass
            }	
            else if(UPSDb.UPSMode[0]=='L')//Line Mode
            {
				*v=1;//Other
            }	
            else if(UPSDb.UPSMode[0]=='B')//Battery Mode
            {
				*v=5;//Battery Mode
            }			
            else if(UPSDb.UPSMode[0]=='T')//Battery test Mode
            {
				*v=8;//Battery test Mode
            }	
            else if(UPSDb.UPSMode[0]=='F')//Fault Mode
            {
				*v=9;//Fault Mode
            }
            else if(UPSDb.UPSMode[0]=='E')//HE/ECO Mode
            {
				*v=10;//HE/ECO Mode
            }
            else if(UPSDb.UPSMode[0]=='C')//Converter Mode
            {
				*v=8;//Converter Mode
            }
            else if(UPSDb.UPSMode[0]=='D')//Shutdown Mode
            {
				*v=1;//other
            }			
            else 
            {
				*v=2;//none
            }
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upsoutput_treenode_get_value(): unknown id: %"S32_F"\n", instance->node->oid));
            value_len = 0;
         }
         break;
   }
   return value_len;
}

/* --- upsBypass 1.3.6.1.4.1.21111.1.1.6 ----------------------------------------------------- */
snmp_err_t upsbytable_get_instance(const u32_t *column, const u32_t *row_oid, u8_t row_oid_len, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    upsByLineIndex (Integer, OID length = 1)
   */
   snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

   if ((row_oid_len == 1) && (*column<=5))
   {
      LWIP_UNUSED_ARG(column);
      LWIP_UNUSED_ARG(row_oid);
      LWIP_UNUSED_ARG(cell_instance);
      /*
      TODO: check if 'row_oid'/'row_oid_len' params contain a valid instance oid for a row
      If so, set 'err = SNMP_ERR_NOERROR;'
      
      snmp_oid_* methods may be used for easier processing of oid
      
      In order to avoid decoding OID a second time in subsequent get_value/set_test/set_value methods,
      you may store an arbitrary value (like a pointer to target value object) in 'cell_instance->reference'/'cell_instance->reference_len'.
      But be aware that not always a subsequent method is called -> Do NOT allocate memory here and try to release it in subsequent methods!
      
      You also may replace function pointers in 'cell_instance' param for get/test/set methods which contain the default values from table definition,
      in order to provide special methods, for the currently processed cell. Changed pointers are only valid for current request.
      */
      err = SNMP_ERR_NOERROR;
   }
   return err;
}
snmp_err_t upsbytable_get_next_instance(const u32_t *column, struct snmp_obj_id *row_oid, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    upsByLineIndex (Integer, OID length = 1)
   */
	 u32_t columnValue=*column;
	 snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;
	
	 LWIP_UNUSED_ARG(column);
	 LWIP_UNUSED_ARG(row_oid);
	 LWIP_UNUSED_ARG(cell_instance);
	
	if((columnValue <5) && (row_oid->len == 1))
	{
	   columnValue+=1;
	   cell_instance->instance_oid.id[0]=1;
	   cell_instance->instance_oid.id[1]=columnValue;
	   err = SNMP_ERR_NOERROR;
	}
	else if((columnValue <5) && (row_oid->len == 0))
	{
	   cell_instance->instance_oid.id[0]=1;
	   cell_instance->instance_oid.id[1]=columnValue;
	   row_oid->len=1;
	   row_oid->id[0]=0;
	   err = SNMP_ERR_NOERROR;
	}
	return err;

}
s16_t upsbytable_get_value(struct snmp_node_instance *cell_instance, void *value)
{
   s16_t value_len;

   switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id))
   {
      case 1:
         {
            /* upsByLineIndex */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.supportedPhase.Bytes.OutputPhase;
         }
         break;
      case 2:
         {
            /* upsByVoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
           *v=UPSDb.OutputVolt;
         }
         break;
      case 3:
         {
            /* upsByCurrent */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.OutputCurr;
         }
         break;
      case 4:
         {
            /* upsByPower */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.OutputVolt * UPSDb.OutputCurr;
         }
         break;
      case 5:
         {
            /* upsByLineVoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upsbytable_get_value(): unknown id: %"S32_F"\n", SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
            value_len = 0;
         }
         break;
   }
   return value_len;
}

s16_t upsbypass_treenode_get_value(struct snmp_node_instance *instance, void *value)
{
   s16_t value_len;

   switch (instance->node->oid)
   {
      case 1:
         {
            /* upsByFrequency */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.OutputFreq;
         }
         break;
      case 2:
         {
            /* upsByNumLines */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.supportedPhase.Bytes.OutputPhase;
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upsbypass_treenode_get_value(): unknown id: %"S32_F"\n", instance->node->oid));
            value_len = 0;
         }
         break;
   }
   return value_len;
}

/* --- ups 1.3.6.1.4.1.21111.1.1 ----------------------------------------------------- */
s16_t upsident_scalars_get_value(const struct snmp_scalar_array_node_def *node, void *value)
{
   s16_t value_len;
   switch (node->oid)
   {

      case 1:
         {
            /* upsIdManufacturer */
            //u8_t *v = (u8_t *)value;

            /* TODO: take care that value with variable length fits into buffer: (value_len <= SNMP_MAX_VALUE_SIZE) */
            /* TODO: take care of len restrictions defined in MIB: ((value_len >= 0) && (value_len <= 31)) */
            /* TODO: put requested value to '*v' here */
            value_len = strlen((const char*)UPSDb.UPSManufacturer);
            MEMCPY(value,UPSDb.UPSManufacturer,value_len);
         }
         break;
      case 2:
         {
            /* upsIdProtocol */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.protocolID; // 1.3.6.1.4.1.21111.1.1.1.2.0:
         }
         break;
      case 3:
         {
            /* upsIdModelName */
           //  u8_t *v = (u8_t *)value;

            /* TODO: take care that value with variable length fits into buffer: (value_len <= SNMP_MAX_VALUE_SIZE) */
            /* TODO: take care of len restrictions defined in MIB: ((value_len >= 0) && (value_len <= 15)) */
            /* TODO: put requested value to '*v' here */
            value_len = strlen((const char*)UPSDb.UPSModel);
            MEMCPY(value,UPSDb.UPSModel,value_len);
         }
         break;
      case 4:
         {
            /* upsIdSerialNumber */
            u8_t *v = (u8_t *)value;

            /* TODO: take care that value with variable length fits into buffer: (value_len <= SNMP_MAX_VALUE_SIZE) */
            /* TODO: take care of len restrictions defined in MIB: ((value_len >= 0) && (value_len <= 31)) */
            /* TODO: put requested value to '*v' here */
            value_len = sizeof(UPSDb.upsID);

            MEMCPY(value,&UPSDb.upsID,value_len);
         }
         break;
      case 5:
         {
            /* upsIdName */
            u8_t *v = (u8_t *)value;

            /* TODO: take care that value with variable length fits into buffer: (value_len <= SNMP_MAX_VALUE_SIZE) */
            /* TODO: take care of len restrictions defined in MIB: ((value_len >= 0) && (value_len <= 31)) */
            /* TODO: put requested value to '*v' here */
            value_len =2;//sizeof(s32_t);//0;
            MEMCPY(value,UPSDb.UPSMode,value_len);//1.3.6.1.4.1.21111.1.1.1.5.0
            //*v=1;//tempsrno1[0];//UPSDb.UPSMode[0];
        //    LWIP_UNUSED_ARG(v);
         }
         break;
      case 6:
         {
            /* upsIdFWVersion */
          //  u8_t *v = (u8_t *)value;

            /* TODO: take care that value with variable length fits into buffer: (value_len <= SNMP_MAX_VALUE_SIZE) */
            /* TODO: take care of len restrictions defined in MIB: ((value_len >= 0) && (value_len <= 31)) */
            /* TODO: put requested value to '*v' here */
            value_len = LWIP_ARRAYSIZE(UPSDb.UPSCPUFwVersion);
            MEMCPY(value,UPSDb.UPSCPUFwVersion,value_len);

         }
         break;
      case 7:
         {
            /* upsIdUPSType *///.1.3.6.1.4.1.21111.1.1.1.7.0
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
      //     *v=UPSDb.upsStatus.Bits.LiveStatus;
         //  *v=UPSDb.UPSMode[0];
            // *v=0x31;//

           if(UPSDb.UPSMode[0]=='P')//Power On Mode
           {
             *v=0;//3;//Normal
           }
           else if(UPSDb.UPSMode[0]=='S')//Standby Mode
           {
               *v=1;//1;//Other
           }
           else if(UPSDb.UPSMode[0]=='Y')//Bypass Mode
           {
               *v=4;//4;//Bypass
           }
           else if(UPSDb.UPSMode[0]=='L')//Line Mode
           {
              *v=2;//1;//Other
           }
           else if(UPSDb.UPSMode[0]=='B')//Battery Mode
           {
               *v=5;//5;//Battery Mode
           }
           else if(UPSDb.UPSMode[0]=='T')//Battery test Mode
           {
               *v=8;//8;//Battery test Mode
           }
           else if(UPSDb.UPSMode[0]=='F')//Fault Mode
           {
               *v=9;//9;//Fault Mode
           }
           else if(UPSDb.UPSMode[0]=='E')//HE/ECO Mode
           {
               *v=10;//10;//HE/ECO Mode
           }
           else if(UPSDb.UPSMode[0]=='C')//Converter Mode
           {
               *v=8;//8;//Converter Mode
           }
           else if(UPSDb.UPSMode[0]=='D')//Shutdown Mode
           {
               *v=1;//1;//other
           }
           else
           {
               *v=2;//2;//none
           }


         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upsident_scalars_get_value(): unknown id: %"S32_F"\n", node->oid));
            value_len = 0;
         }
         break;
   }
   return value_len;
}
snmp_err_t upsident_scalars_set_test(const struct snmp_scalar_array_node_def *node, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_WRONGVALUE;

   switch (node->oid)
   {
      case 5:
         {
            /* upsIdName */
            u8_t *v = (u8_t *)value;

            if ((len <= 31))
            {
                err = SNMP_ERR_NOTWRITABLE;// err = SNMP_ERR_NOERROR;
            }
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upsident_scalars_set_test(): unknown id: %"S32_F"\n", node->oid));
         }
         break;
   }
   return err;
}
snmp_err_t upsident_scalars_set_value(const struct snmp_scalar_array_node_def *node, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_NOERROR;

   LWIP_UNUSED_ARG(len);
   switch (node->oid)
   {
      case 5:
         {
            /* upsIdName */
            u8_t *v = (u8_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upsident_scalars_set_value(): unknown id: %"S32_F"\n", node->oid));
         }
         break;
   }
   return err;
}

s16_t upsrating_scalars_get_value(const struct snmp_scalar_array_node_def *node, void *value)
{
   s16_t value_len;

   switch (node->oid)
   {
      case 1:
         {
            /* upsRatinVoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
             *v=UPSDb.RatedOuputVolt;
         }
         break;
      case 2:
         {
            /* upsRatoutVoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.RatedOuputVolt;
         }
         break;
      case 3:
         {
            /* upsRatoutFrequency */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.RatedOuputFreq;
         }
         break;
      case 4:
         {
            /* upsRatoutCurrent */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.RatedOuputCurr;
         }
         break;
      case 5:
         {
            /* upsRatoutApparentPower */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
			*v=UPSDb.RatedOutputVA;
         }
         break;
      case 6:
         {
            /* upsRatoutTruePower */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.RatedOutputVA;
         }
         break;
      case 7:
         {
            /* upsRatBatVoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.RatedBattVolt;
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upsrating_scalars_get_value(): unknown id: %"S32_F"\n", node->oid));
            value_len = 0;
         }
         break;
   }
   return value_len;
}

s16_t upsbattery_scalars_get_value(const struct snmp_scalar_array_node_def *node, void *value)
{
   s16_t value_len;

   switch (node->oid)
   {
      case 1:
         {
            /* upsBatStatus */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
           	if(UPSDb.upsStatus.Bits.batTestOK==1)
            {
				*v=2;// Unkmown
            }				
			else if(UPSDb.warningFlags.Bits.BattLow==1)
            {
				*v=3;// Battery Low
            }		
            else if(UPSDb.warningFlags.Bits.BatteryOpen==1)
            {
				*v=4;// Battery Depleted
            }
	
            else if(UPSDb.UPSMode[0]=='B')
            {
				*v=5;// Battery discharging
            }	
            else if(UPSDb.warningFlags.Bits.BatteryOpen==1)
            {
				*v=6;// Battery Failed
            }			
            else if(UPSDb.warningFlags.Bits.BatteryReplace==1)
            {
				*v=7;// Battery Depleted
            }	
            else if(UPSDb.upsStatus.Bits.battSilence==1)
            {
				*v=8;// Battery Depleted
            }
            else 
            {
				*v=2;// Unkmown
            }				
         }
         break;
      case 2:
         {
            /* upsBatSecondsOnBattery */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 3:
         {
            /* upsBatEstMinutesRemaining */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.BattRemainTime;
         }
         break;
      case 4:
         {
            /* upsBatEstChargeRemaining */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 5:
         {
            /* upsBatPBatVoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
             *v=UPSDb.PBattVolt;
         }
         break;
      case 6:
         {
            /* upsBatNBatVoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.NBattVolt;
         }
         break;
      case 7:
         {
            /* upsBatPBatCurrent */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 8:
         {
            /* upsBatNBatCurrent */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 9:
         {
            /* upsBatPBatChargCurrent */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 10:
         {
            /* upsBatNBatchargCurrent */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 11:
         {
            /* upsBatPBatDischargCurrent */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 12:
         {
            /* upsBatNBatDischargCurrent */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 13:
         {
            /* upsBatTemperature */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.MaxTemp;
         }
         break;
      case 14:
         {
            /* upsBatNumberInSeries */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.BattPieceNumber;
         }
         break;
      case 15:
         {
            /* upsBatNumberInParallel */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.BattgroupNumber;
         }
         break;
      case 16:
         {
            /* upsBatPBatDischargCurrent2 */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upsbattery_scalars_get_value(): unknown id: %"S32_F"\n", node->oid));
            value_len = 0;
         }
         break;
   }
   return value_len;
}

s16_t upstest_scalars_get_value(const struct snmp_scalar_array_node_def *node, void *value)
{
   s16_t value_len;

   switch (node->oid)
   {
      case 1:
         {
            /* upsTstBatteryTest */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.BatteryTestType;
         }
         break;
      case 2:
         {
            /* upsTstBatteryTestResult */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
           	if(UPSDb.upsStatus.Bits.batTestOK==1)
            {
				*v=1;// passed
            }				
			else if(UPSDb.upsStatus.Bits.battTestFail==1)
            {
				*v=3;// failed
            }
			else
            {
				*v=6;// not initiated
            }			
         }
         break;
      case 3:
         {
            /* upsTstBatteryTestStartTime */
            u8_t *v = (u8_t *)value;

            /* TODO: take care that value with variable length fits into buffer: (value_len <= SNMP_MAX_VALUE_SIZE) */
            /* TODO: take care of len restrictions defined in MIB: (value_len == 19) */
            /* TODO: put requested value to '*v' here */
            value_len = 0;
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 4:
         {
            /* upsTstBatterySettingTime */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upstest_scalars_get_value(): unknown id: %"S32_F"\n", node->oid));
            value_len = 0;
         }
         break;
   }
   return value_len;
}
snmp_err_t upstest_scalars_set_test(const struct snmp_scalar_array_node_def *node, u16_t len, void *value)
{
    snmp_err_t err = SNMP_ERR_WRONGVALUE;
    char text_string[10] = {0};
    UPS_WRITE_REQUEST pReqParam;
    uint8_t status=WRITE_SUCCESS;
	uint32_t tempData=0;
	
   switch (node->oid)
   {
      case 1:
         {
            /* upsTstBatteryTest */
            s32_t *v = (s32_t *)value;
            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
			UPSDb.BatteryTestType=*v;
			  if (((*v >5) || (*v < 2)) )
            {
			     return err;
            }
			else
			{
               pReqParam.taskID=SNMP_TASK_ID;
               if(*v==2)
                {
                    sprintf((char *)pReqParam.ctrlcommand,"%s","T\r");
                    pReqParam.ctrlcmdSize=T_CMD_SIZE;
                }
                else if(*v==3)
                {
                    sprintf((char *)pReqParam.ctrlcommand,"%s","TL\r");
                    pReqParam.ctrlcmdSize=TL_CMD_SIZE;
                }
                else if(*v==4)
                {
                     sprintf((char *)pReqParam.ctrlcommand,"%c%d%c",'T',*v,'\r');
                      pReqParam.ctrlcmdSize=T_N_CMD_SIZE;
                }
                else if(*v==5)
                {
                   sprintf((char *)pReqParam.ctrlcommand,"%s","CT\r");
                   pReqParam.ctrlcmdSize=CS_CMD_SIZE;
                }
                status=UPSInterface_InitiateWriteRequest(&pReqParam);
                if(status==WRITE_SUCCESS)
                {
                      err = SNMP_ERR_NOERROR;
                }
			}
         }
         break;
      case 4:
         {
            /* upsTstBatterySettingTime */
           s32_t *v = (s32_t *)value;
           LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
           if (((*v > 5940) || (*v < 12)))  //As per document these value range is modified
             {
                   return err;
             }
           else
           {            
				UPSDb.BattRemainTime=*v;
				sprintf((char *)pReqParam.ctrlcommand,"%c%2.1f%c",'T',(float)(*v/60),'\r');
				pReqParam.ctrlcmdSize=T_N_CMD_SIZE;
				status=UPSInterface_InitiateWriteRequest(&pReqParam);
				if(status==WRITE_SUCCESS)
				{
					err = SNMP_ERR_NOERROR;
				}
				
               
           }
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upstest_scalars_set_test(): unknown id: %"S32_F"\n", node->oid));
         }
         break;
   }
   return err;
}
snmp_err_t upstest_scalars_set_value(const struct snmp_scalar_array_node_def *node, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_NOERROR;

   LWIP_UNUSED_ARG(len);

   switch (node->oid)
   {
     case 1:
           {
              /* upsTstBatteryTest */
              s32_t *v = (s32_t *)value;

              /* TODO: store new value contained in '*v' here */
              UPSDb.BatteryTestType=*v;
           }
      break;
      case 4:
         {
            /* upsTstBatterySettingTime */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upstest_scalars_set_value(): unknown id: %"S32_F"\n", node->oid));
         }
         break;
   }
   return err;
}

s16_t upscontrol_scalars_get_value(const struct snmp_scalar_array_node_def *node, void *value)
{
   s16_t value_len;

   switch (node->oid)
   {
      case 1:
         {
            /* upsCtlShutdownDelay */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 2:
         {
            /* upsCtlSleepTime */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 3:
         {
            /* upsCtlStartupAfterDelay */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 4:
         {
            /* upsCtlbuzzer */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 5:
         {
            /* upsCtlRemoteControlUPS */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 6:
         {
            /* upsCtloutletPoweron */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 7:
         {
            /* upsCtloutletPoweroff */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 8:
         {
            /* upsCtlOutlet1Powerofftime */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 9:
         {
            /* upsCtlOutlet2Powerofftime */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 10:
         {
            /* upsCtlResetConfigure */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upscontrol_scalars_get_value(): unknown id: %"S32_F"\n", node->oid));
            value_len = 0;
         }
         break;
   }
   return value_len;
}
snmp_err_t upscontrol_scalars_set_test(const struct snmp_scalar_array_node_def *node, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_WRONGVALUE;
   char text_string[10] = {0};
   UPS_WRITE_REQUEST pReqParam;
   uint8_t status=WRITE_SUCCESS;
   uint32_t tempData=0;
   
   switch (node->oid)
   {
      case 1:
         {
            /* upsCtlShutdownDelay */
            s32_t *v = (s32_t *)value;
            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));

            if (((*v < -2) || (*v > 600))) //if (((*v < -2) || (*v > 2147483648)))
            {
               return err;
            }
            else
            {
                pReqParam.taskID=SNMP_TASK_ID;
                tempData=*v;
                sprintf(text_string,"%02d", tempData);
                if(*v==-2)
                {
                    sprintf((char *)pReqParam.ctrlcommand,"%s","CS\r");
                    pReqParam.ctrlcmdSize=CS_CMD_SIZE;
                }
                else if(*v!=-1)
                {
                    sprintf((char *)pReqParam.ctrlcommand,"%c%0d%c",'S',*v,'\r');
                    pReqParam.ctrlcmdSize=SN_CMD_SIZE;
                    status=UPSInterface_InitiateWriteRequest(&pReqParam);
                    if(status==WRITE_SUCCESS)
                    {
                        err = SNMP_ERR_NOERROR;
                    }
                }
            }
         }
         break;
      case 2:
         {
            /* upsCtlSleepTime */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v >= -1) && (*v <= 2147483648)))
            {
                err = SNMP_ERR_NOTWRITABLE;//err = SNMP_ERR_NOERROR;
            }
         }
         break;
      case 3:
         {
            /* upsCtlStartupAfterDelay */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));

            if (((*v > 9999) ||(*v < 1)))         //if (((*v >= -2) && (*v <= 2147483648)))
            {
                  return err;
            }
            else
            {
                tempData=*v;
                sprintf((char*)pReqParam.ctrlcommand,"%c%2d%c%04d%c",'S', UPSDb.BattRemainTime,'R',tempData,'\r');
                pReqParam.ctrlcmdSize=SNR_CMD_SIZE;
                status=UPSInterface_InitiateWriteRequest(&pReqParam);
                if(status==WRITE_SUCCESS)
                {
                     err = SNMP_ERR_NOERROR;
                }
            }

         }
         break;
      case 4:
         {
            /* upsCtlbuzzer */
            s32_t *v = (s32_t *)value;
           LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
           if (((*v > 2)||(*v < 1)))
            {
                   return err;
            }
           else
           {
               pReqParam.taskID=SNMP_TASK_ID;
               if(*v==1)
               {
                   sprintf((char *)pReqParam.ctrlcommand,"%s","BZON\r");
                   pReqParam.ctrlcmdSize=BZON_CMD_SIZE;
               }
               else if(*v==2)
               {
                   sprintf((char *)pReqParam.ctrlcommand,"%s","BZOFF\r");
                   pReqParam.ctrlcmdSize=BZOFF_CMD_SIZE;
               }
               status=UPSInterface_InitiateWriteRequest(&pReqParam);
               if(status==WRITE_SUCCESS)
               {
                      err = SNMP_ERR_NOERROR;

                }
              }
            }
         break;
      case 5:
         {
             /* upsCtlRemoteControlUPS */
           s32_t *v = (s32_t *)value;
            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v > 2) ||(*v < 1)))
            {
                return err;
            }
            else
            {
                pReqParam.taskID=SNMP_TASK_ID;
                tempData=*v;
                if(*v==1)
                {
                    sprintf((char *)pReqParam.ctrlcommand,"%s","SON\r");
                    pReqParam.ctrlcmdSize=SON_CMD_SIZE;
                }
                else if(*v==2)
                {
                    sprintf((char *)pReqParam.ctrlcommand,"%s","SOFF\r");
                    pReqParam.ctrlcmdSize=SOFF_CMD_SIZE;
                }
                status=UPSInterface_InitiateWriteRequest(&pReqParam);
                if(status==WRITE_SUCCESS)
                {
                    err = SNMP_ERR_NOERROR;
                }
            }
         }
         break;
      case 6:
         {
            /* upsCtloutletPoweron */
            s32_t *v = (s32_t *)value;
            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v > 2)||(*v < 1)))
           {
               return err;
           }
           else
           {

               if(*v==1)
              {
                sprintf((char *)pReqParam.ctrlcommand,"%s","SKON1\r");
              }
              else if(*v==2)
              {
                  sprintf((char *)pReqParam.ctrlcommand,"%s","SKON2\r");
              }

//               if(*v==1)
//               {
//                   sprintf((char *)pReqParam.ctrlcommand,"%s%d%c","SKON1\r");
//               }
//               if(v*==2)
//               {
//                   sprintf((char *)pReqParam.ctrlcommand,"%s","SKON2\r");
//               }
                pReqParam.taskID=SNMP_TASK_ID;

                pReqParam.ctrlcmdSize=SKONN_CMD_SIZE;
               status=UPSInterface_InitiateWriteRequest(&pReqParam);
               if(status==WRITE_SUCCESS)
               {
                    err = SNMP_ERR_NOERROR;
               }
           }
         }
         break;
      case 7:
         {
            /* upsCtloutletPoweroff */
           s32_t *v = (s32_t *)value;
           LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
           if (((*v > 2)||(*v < 1 )))
          {
              return err;
          }
          else
          {
              if(*v==1)
                {
                  sprintf((char *)pReqParam.ctrlcommand,"%s","SKOFF1\r");
                }
                else if(*v==2)
                {
                    sprintf((char *)pReqParam.ctrlcommand,"%s","SKOFF2\r");
                }

//              if(*v==1)
//                 {
//                     sprintf((char *)pReqParam.ctrlcommand,"%s","SKOFF1\r");
//                 }
//                 if(v*==2)
//                 {
//                     sprintf((char *)pReqParam.ctrlcommand,"%s","SKOFF2\r");
//                 }
                pReqParam.taskID=SNMP_TASK_ID;
                pReqParam.ctrlcmdSize=SKOFFN_CMD_SIZE;
                status=UPSInterface_InitiateWriteRequest(&pReqParam);
                if(status==WRITE_SUCCESS)
                {
                   err = SNMP_ERR_NOERROR;
                }
             }
         }
         break;
      case 8:
         {
            /* upsCtlOutlet1Powerofftime */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v >999) ||(*v <-1 )))
           {
               return err;
           }
           else
           {
            pReqParam.taskID=SNMP_TASK_ID;

            sprintf((char *)pReqParam.ctrlcommand,"%s%d%c","PSK1", *v,'\r');
            pReqParam.ctrlcmdSize=PSK_CMD_SIZE;
            status=UPSInterface_InitiateWriteRequest(&pReqParam);
            if(status==WRITE_SUCCESS)
            {
                err = SNMP_ERR_NOERROR;
             }
           }
         }
         break;
      case 9:
         {
            /* upsCtlOutlet2Powerofftime */
            s32_t *v = (s32_t *)value;
            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v >999) ||(*v <-1)))
           {
               return err;
           }
           else
           {
                sprintf((char *)pReqParam.ctrlcommand,"%s%d%c","PSK2", *v,'\r');
                pReqParam.ctrlcmdSize=PSK_CMD_SIZE;
                status=UPSInterface_InitiateWriteRequest(&pReqParam);
                if(status==WRITE_SUCCESS)
                {
                    err = SNMP_ERR_NOERROR;
                }
           }
         }
         break;
      case 10:
         {
            /* upsCtlResetConfigure */
           s32_t *v = (s32_t *)value;
           LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (( (*v > 1)||(*v <0)))
            {
                return err;
            }
            else
            {
                pReqParam.taskID=SNMP_TASK_ID;
                sprintf((char *)pReqParam.ctrlcommand,"%s","PF\r");
                pReqParam.ctrlcmdSize=PF_CMD_SIZE;
                status=UPSInterface_InitiateWriteRequest(&pReqParam);
                if(status==WRITE_SUCCESS)
                {
                    err = SNMP_ERR_NOERROR;
                }
            }
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upscontrol_scalars_set_test(): unknown id: %"S32_F"\n", node->oid));
         }
         break;
   }
   return err;
}
snmp_err_t upscontrol_scalars_set_value(const struct snmp_scalar_array_node_def *node, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_NOERROR;

   LWIP_UNUSED_ARG(len);
   switch (node->oid)
   {
      case 1:
         {
            /* upsCtlShutdownDelay */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 2:
         {
            /* upsCtlSleepTime */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 3:
         {
            /* upsCtlStartupAfterDelay */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 4:
         {
            /* upsCtlbuzzer */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 5:
         {
            /* upsCtlRemoteControlUPS */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 6:
         {
            /* upsCtloutletPoweron */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 7:
         {
            /* upsCtloutletPoweroff */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 8:
         {
            /* upsCtlOutlet1Powerofftime */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 9:
         {
            /* upsCtlOutlet2Powerofftime */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 10:
         {
            /* upsCtlResetConfigure */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upscontrol_scalars_set_value(): unknown id: %"S32_F"\n", node->oid));
         }
         break;
   }
   return err;
}

s16_t agentconfig_scalars_get_value(const struct snmp_scalar_array_node_def *node, void *value)
{
   s16_t value_len;

   switch (node->oid)
   {
      case 1:
         {
            /* agentConfigDatetime */
            u8_t *v = (u8_t *)value;

            /* TODO: take care that value with variable length fits into buffer: (value_len <= SNMP_MAX_VALUE_SIZE) */
            /* TODO: take care of len restrictions defined in MIB: (value_len == 19) */
            /* TODO: put requested value to '*v' here */
            value_len = 0;
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("agentconfig_scalars_get_value(): unknown id: %"S32_F"\n", node->oid));
            value_len = 0;
         }
         break;
   }
   return value_len;
}
snmp_err_t agentconfig_scalars_set_test(const struct snmp_scalar_array_node_def *node, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_WRONGVALUE;

   switch (node->oid)
   {
      case 1:
         {
            /* agentConfigDatetime */
            u8_t *v = (u8_t *)value;

            if ((len == 19))
            {
                err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
            }
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("agentconfig_scalars_set_test(): unknown id: %"S32_F"\n", node->oid));
         }
         break;
   }
   return err;
}
snmp_err_t agentconfig_scalars_set_value(const struct snmp_scalar_array_node_def *node, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_NOERROR;

   LWIP_UNUSED_ARG(len);
   switch (node->oid)
   {
      case 1:
         {
            /* agentConfigDatetime */
            u8_t *v = (u8_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("agentconfig_scalars_set_value(): unknown id: %"S32_F"\n", node->oid));
         }
         break;
   }
   return err;
}

s16_t commconfig_scalars_get_value(const struct snmp_scalar_array_node_def *node, void *value)
{
   s16_t value_len;

   switch (node->oid)
   {
      case 1:
         {
            /* commBaudRate */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 2:
         {
            /* commDatabits */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 3:
         {
            /* commStopbits */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 4:
         {
            /* commParity */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 5:
         {
            /* commTimeout */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("commconfig_scalars_get_value(): unknown id: %"S32_F"\n", node->oid));
            value_len = 0;
         }
         break;
   }
   return value_len;
}
snmp_err_t commconfig_scalars_set_test(const struct snmp_scalar_array_node_def *node, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_WRONGVALUE;
   UPS_WRITE_REQUEST pReqParam;
   uint8_t status=WRITE_SUCCESS;
   uint32_t tempData=0;
	
   switch (node->oid)
   {
      case 1:
         {
            /* commBaudRate */
           s32_t *v = (s32_t *)value;
           LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));

           if (((*v >5) ||(*v < 1) ))
           {
               return err;
           }
           else
           {
               pReqParam.taskID=SNMP_TASK_ID;
               if(*v==1)
               {
                  sprintf((char *)pReqParam.ctrlcommand,"%s","BDR12\r");
               }
               else if(*v==2)
                 {
                  sprintf((char *)pReqParam.ctrlcommand,"%s","BDR24\r");
                 }
               else if(*v==3)
                 {
                  sprintf((char *)pReqParam.ctrlcommand,"%s","BDR48\r");
                 }
               else if(*v==4)
                 {
                  sprintf((char *)pReqParam.ctrlcommand,"%s","BDR96\r");
                 }
                else if(*v==5)
                 {
                  sprintf((char *)pReqParam.ctrlcommand,"%s","BDR19\r");
                 }
               pReqParam.ctrlcmdSize=BDR_CMD_SIZE;
               status=UPSInterface_InitiateWriteRequest(&pReqParam);
               if(status==WRITE_SUCCESS)
               {
                  err = SNMP_ERR_NOERROR;
                }
             }
         }
         break;
      case 2:
         {
            /* commDatabits */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v >= 8) && (*v <= 9)))
            {
                err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
            }
         }
         break;
      case 3:
         {
            /* commStopbits */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v >= 1) && (*v <= 2)))
            {
                err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
            }
         }
         break;
      case 4:
         {
            /* commParity */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v >= 0) && (*v <= 2)))
            {
                err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
            }
         }
         break;
      case 5:
         {
            /* commTimeout */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v >= 100) && (*v <= 1000)))
            {
                err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
            }
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("commconfig_scalars_set_test(): unknown id: %"S32_F"\n", node->oid));
         }
         break;
   }
   return err;
}
snmp_err_t commconfig_scalars_set_value(const struct snmp_scalar_array_node_def *node, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_NOERROR;

   LWIP_UNUSED_ARG(len);
   switch (node->oid)
   {
      case 1:
         {
            /* commBaudRate */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 2:
         {
            /* commDatabits */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 3:
         {
            /* commStopbits */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 4:
         {
            /* commParity */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 5:
         {
            /* commTimeout */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("commconfig_scalars_set_value(): unknown id: %"S32_F"\n", node->oid));
         }
         break;
   }
   return err;
}

s16_t upsconfig_scalars_get_value(const struct snmp_scalar_array_node_def *node, void *value)
{
   s16_t value_len;

   switch (node->oid)
   {
      case 1:
         {
            /* upsCfgAlarmbypass */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=UPSDb.settingFlags.upsFlagsBits.bypassAudibleWarning;
         }
         break;
      case 2:
         {
            /* upsCfgAlarmbattery */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=UPSDb.settingFlags.upsFlagsBits.battModeAudibleWarning;
         }
         break;
      case 3:
         {
            /* upsCfgAutoReboot */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=UPSDb.settingFlags.upsFlagsBits.autoRestart;
         }
         break;
      case 4:
         {
            /* upsCfgBypasswhenupsoff */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=UPSDb.settingFlags.upsFlagsBits.bypasWhenUPSTurnOff;
         }
         break;
      case 5:
         {
            /* upsCfgBatterDDP */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=UPSDb.settingFlags.upsFlagsBits.battDeepDischProtect;
         }
         break;
      case 6:
         {
            /* upsCfgConvertermode */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=UPSDb.settingFlags.upsFlagsBits.converterMode;
         }
         break;
      case 7:
         {
            /* upsCfgECOmode */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=UPSDb.settingFlags.upsFlagsBits.energySaving;
         }
         break;
      case 8:
         {
            /* upsCfgAdvanceECOmode */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=2;// Not supported

         }
         break;
      case 9:
         {
            /* upsCfgGreenPowerFunction */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=2;// Not supported
         }
         break;
      case 10:
         {
            /* upsCfgBatteryOSC */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=2;// Not supported
         }
         break;
      case 11:
         {
            /* upsCfgAllowShort3times */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=UPSDb.settingFlags.upsFlagsBits.shortRestart3Times;
         }
         break;
      case 12:
         {
            /* upsCfgColdstart */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=UPSDb.settingFlags.upsFlagsBits.codeStart;
         }
         break;
      case 13:
         {
            /* upsCfgBypassNotAllowed */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=UPSDb.settingFlags.upsFlagsBits.bypassForbiding;
         }
         break;
      case 14:
         {
            /* upsCfgBatterylowprotect */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=2;// Not supported

         }
         break;
      case 15:
         {
            /* upsCfgP1progoutletcontrol */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=2;// Not supported

         }
         break;
      case 16:
         {
            /* upsCfgP2progoutletcontrol */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=2;// Not supported

         }
         break;
      case 17:
         {
            /* upsCfgInverterShortClear */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=2;// Not supported

         }
         break;
      case 18:
         {
            /* upsCfgSitefaildetection */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=2;// Not supported

         }
         break;
      case 19:
         {
            /* upsCfgBatNumInParallel */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v = UPSDb.BatNumberInParallel;
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 20:
         {
            /* upsCfgBatNumInSeries */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 21:
         {
            /* upsCfgBypassmaxvoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=UPSDb.bypassVoltHighLossPt;
         }
         break;
      case 22:
         {
            /* upsCfgBypassminvoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=UPSDb.bypassVoltLowLossPt;
         }
         break;
      case 23:
         {
            /* upsCfgBypassmaxfrequency */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=UPSDb.freqHighLossPt;

         }
         break;
      case 24:
         {
            /* upsCfgBypassminfrequency */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=UPSDb.freqLowLossPt;
         }
         break;
      case 25:
         {
            /* upsCfgECOmaxvoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=UPSDb.voltHighLossPt;

         }
         break;
      case 26:
         {
            /* upsCfgECOminvoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=UPSDb.voltLowLossPt;

         }
         break;
      case 27:
         {
            /* upsCfgFreeRunMaxFrequency */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 28:
         {
            /* upsCfgFreeRunMinFrequency */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 29:
         {
            /* upsCfgEPOStatus */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=UPSDb.upsStatus.Bits.EPO;
         }
         break;
      case 30:
         {
            /* upsCfgQSK1Status */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 31:
         {
            /* upsCfgQSK2Status */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 32:
         {
            /* upsCfgQSKT1Delaytime */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 33:
         {
            /* upsCfgQSKT2Delaytime */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 34:
         {
            /* upsCfgConstantPhaseAngle */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 35:
         {
            /* upsCfgInPhaseAngle */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 36:
         {
            /* upsCfgOutPhaseAngle */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 37:
         {
            /* upsCfgLimiRunOnBatMode */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=2;// Not supported
         }
         break;
      case 38:
         {
            /* upsCfgChargingCurrent */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 39:
         {
            /* upsCfgBatSeftCheckVolt */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 40:
         {
            /* upsCfgOverChargVolt */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 41:
         {
            /* upsCfgBattUnderVolt */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 42:
         {
            /* upsCfgBattLowVolt */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 43:
         {
            /* upsCfgIn1VoltHLoss */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 44:
         {
            /* upsCfgIn1VoltLLoss */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 45:
         {
            /* upsCfgIn2VoltHLoss */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 46:
         {
            /* upsCfgIn2VoltLLoss */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 47:
         {
            /* upsCfgBatteryTurnOn */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
			value_len = sizeof(s32_t);
            *v=2;// Not supported
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upsconfig_scalars_get_value(): unknown id: %"S32_F"\n", node->oid));
            value_len = 0;
         }
         break;
   }
   return value_len;
}
snmp_err_t upsconfig_scalars_set_test(const struct snmp_scalar_array_node_def *node, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_WRONGVALUE;
   char text_string[10] = {0};
   UPS_WRITE_REQUEST pReqParam;
   uint8_t status=WRITE_SUCCESS;
   uint32_t tempData=0;

   switch (node->oid)
   {
      case 1:
       {
            /* upsCfgAlarmbypass */
        s32_t *v = (s32_t *)value;
        LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
        if (((*v < 0) || (*v > 1)))
        {
            return err;
        }
        else
        {
            pReqParam.taskID=SNMP_TASK_ID;

            if(*v==0)
            {
             	sprintf((char *)pReqParam.ctrlcommand,"%s","PDP\r");
             }
            else if(*v==1)
            {
            	sprintf((char *)pReqParam.ctrlcommand,"%s","PEP\r");
          
            }
            pReqParam.ctrlcmdSize=PEPD_CMD_SIZE;
            pReqParam.writeState=STATE_UPS_WRITE_EMPTY;
            status=UPSInterface_InitiateWriteRequest(&pReqParam);

             if(status==WRITE_SUCCESS)
             {
                 err = SNMP_ERR_NOERROR;
             }

         }

     }
     break;
      case 2:
         {
            /* upsCfgAlarmbattery */
            s32_t *v = (s32_t *)value;
            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v < 0) || (*v > 1)))
            {
                return err;
            }
            else
            {
                pReqParam.taskID=SNMP_TASK_ID;
             
                if(*v==0)
                {
               		sprintf((char *)pReqParam.ctrlcommand,"%s","PDB\r");
                }
                else if(*v==1)
                {
               		sprintf((char *)pReqParam.ctrlcommand,"%s","PEB\r");
                }
                pReqParam.ctrlcmdSize=PEPD_CMD_SIZE;
                status=UPSInterface_InitiateWriteRequest(&pReqParam);
                if(status==WRITE_SUCCESS)
                {
                    err = SNMP_ERR_NOERROR;
                }
            }

         }
         break;
      case 3:
         {
            /* upsCfgAutoReboot */
            s32_t *v = (s32_t *)value;
            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v < 0) || (*v > 1)))
            {
                return err;
            }
            else
            {
                pReqParam.taskID=SNMP_TASK_ID;
                if(*v==0)
               {
                 sprintf((char *)pReqParam.ctrlcommand,"%s","PDR\r");      
               }
               else if(*v==1)
               {
              	 sprintf((char *)pReqParam.ctrlcommand,"%s","PER\r");    
               }
                pReqParam.ctrlcmdSize=PEPD_CMD_SIZE;

               status=UPSInterface_InitiateWriteRequest(&pReqParam);
               if(status==WRITE_SUCCESS)
               {
                   err = SNMP_ERR_NOERROR;
               }
            }

         }
         break;
      case 4:
         {
            /* upsCfgBypasswhenupsoff */
            s32_t *v = (s32_t *)value;
            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v < 0) || (*v > 1)))
            {
                return err;
            }
            else
            {
                pReqParam.taskID=SNMP_TASK_ID;
             
                if(*v==0)
                {
               	  sprintf((char *)pReqParam.ctrlcommand,"%s","PDO\r");            
                }
                else if(*v==1)
                {
              	  sprintf((char *)pReqParam.ctrlcommand,"%s","PEO\r"); 
                 
                }
                pReqParam.ctrlcmdSize=PEPD_CMD_SIZE;
                status=UPSInterface_InitiateWriteRequest(&pReqParam);
                if(status==WRITE_SUCCESS)
                {
                    err = SNMP_ERR_NOERROR;
                }
            }

         }
         break;
      case 5:
         {
            /* upsCfgBatterDDP */
            s32_t *v = (s32_t *)value;
            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v < 0) || (*v > 1)))
            {
                return err;
            }
            else
            {
                pReqParam.taskID=SNMP_TASK_ID;
                if(*v==0)
                {
                    sprintf((char *)pReqParam.ctrlcommand,"%s","PDS\r");
                }
                else if(*v==1)
                {
                   sprintf((char *)pReqParam.ctrlcommand,"%s","PES\r");
                }
                pReqParam.ctrlcmdSize=PEPD_CMD_SIZE;
                status=UPSInterface_InitiateWriteRequest(&pReqParam);
                if(status==WRITE_SUCCESS)
                {
                   err = SNMP_ERR_NOERROR;
                }
            }

         }
         break;
      case 6:
         {
            /* upsCfgConvertermode */
            s32_t *v = (s32_t *)value;
            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v < 0) || (*v > 1)))
            {
                return err;
            }
            else
            {
               pReqParam.taskID=SNMP_TASK_ID;
               if(*v==0)
               {
                   sprintf((char *)pReqParam.ctrlcommand,"%s","PDV\r");
                }
               else if(*v==1)
               {
                   sprintf((char *)pReqParam.ctrlcommand,"%s","PEV\r");
                }
               pReqParam.ctrlcmdSize=PEPD_CMD_SIZE;

               status=UPSInterface_InitiateWriteRequest(&pReqParam);
               if(status==WRITE_SUCCESS)
               {
                  err = SNMP_ERR_NOERROR;
               }
            }
         }
         break;
      case 7:
         {
            /* upsCfgECOmode */
            s32_t *v = (s32_t *)value;
            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v < 0) || (*v > 1)))
            {
                return err;
            }
            else
            {
                pReqParam.taskID=SNMP_TASK_ID;
           
                if(*v==0)
                {
                    sprintf((char *)pReqParam.ctrlcommand,"%s","PDE\r");
                }
                else if(*v==1)
                {
                    sprintf((char *)pReqParam.ctrlcommand,"%s","PEE\r");
                 
                }
                pReqParam.ctrlcmdSize=PEPD_CMD_SIZE;

                status=UPSInterface_InitiateWriteRequest(&pReqParam);
                if(status==WRITE_SUCCESS)
                {
                       err = SNMP_ERR_NOERROR;
                }
            }
         }
         break;
      case 8:
         {
            /* upsCfgAdvanceECOmode */
            s32_t *v = (s32_t *)value;
            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v < 0) || (*v > 1)))
            {
                return err;
            }
            else
            {
                pReqParam.taskID=SNMP_TASK_ID;
                if(*v==0)
                {
                    sprintf((char *)pReqParam.ctrlcommand,"%s","PDG\r");
                 }
                else if(*v==1)
                {
                    sprintf((char *)pReqParam.ctrlcommand,"%s","PEG\r");
                }
                 pReqParam.ctrlcmdSize=PEPD_CMD_SIZE;

                status=UPSInterface_InitiateWriteRequest(&pReqParam);
                if(status==WRITE_SUCCESS)
                {
                    err = SNMP_ERR_NOERROR;
                }
            }
         }
         break;
      case 9:
         {
            /* upsCfgGreenPowerFunction */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v < 0) || (*v > 1)))
           {
               return err;
           }
           else
           {
               pReqParam.taskID=SNMP_TASK_ID;
         
               if(*v==0)     //This is considered as Deep high efficiency mode
               {
                   sprintf((char *)pReqParam.ctrlcommand,"%s","PDN\r");
               }
               else if(*v==1)
               {
                   sprintf((char *)pReqParam.ctrlcommand,"%s","PEN\r");
             }
         

               pReqParam.ctrlcmdSize=PEPD_CMD_SIZE;

               status=UPSInterface_InitiateWriteRequest(&pReqParam);
               if(status==WRITE_SUCCESS)
               {
                   err = SNMP_ERR_NOERROR;
               }
           }
         }
         break;
      case 10:
         {
            /* upsCfgBatteryOSC */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v < 0) || (*v > 1)))
             {
                 return err;
             }
             else
             {
                 pReqParam.taskID=SNMP_TASK_ID;
            
                 if(*v==0)
                 {
                	 sprintf((char *)pReqParam.ctrlcommand,"%s","PDD\r");
                   
                 }
                 else if(*v==1)
                 {
                 	sprintf((char *)pReqParam.ctrlcommand,"%s","PED\r");
               
                 }
                 pReqParam.ctrlcmdSize=PEPD_CMD_SIZE;

                 status=UPSInterface_InitiateWriteRequest(&pReqParam);
                 if(status==WRITE_SUCCESS)
                 {
                     err = SNMP_ERR_NOERROR;
                 }
             }
         }
         break;
      case 11:
         {
            /* upsCfgAllowShort3times */
            s32_t *v = (s32_t *)value;
            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v < 0) || (*v > 1)))
           {
               return err;
           }
           else
           {
                pReqParam.taskID=SNMP_TASK_ID;
             
                 if(*v==0)
                 {
                 	sprintf((char *)pReqParam.ctrlcommand,"%s","PDH\r");
                
                 }
                 else if(*v==1)
                 {
                	 sprintf((char *)pReqParam.ctrlcommand,"%s","PEH\r");  
                 }
             
                 pReqParam.ctrlcmdSize=PEPD_CMD_SIZE;

                 status=UPSInterface_InitiateWriteRequest(&pReqParam);
                 if(status==WRITE_SUCCESS)
                 {
                      err = SNMP_ERR_NOERROR;
                 }
            }
         }
         break;
      case 12:
         {
            /* upsCfgColdstart */
           s32_t *v = (s32_t *)value;
           LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
           if (((*v <0) || (*v >1)))
           {
              return err;
           }
           else
           {
           pReqParam.taskID=SNMP_TASK_ID;
            if(*v==0)
            {
          	  sprintf((char *)pReqParam.ctrlcommand,"%s","PDC\r");
            }
            else if(*v==1)
            {
             sprintf((char *)pReqParam.ctrlcommand,"%s","PEC\r");       
            }       
            pReqParam.ctrlcmdSize=PEPD_CMD_SIZE;

            status=UPSInterface_InitiateWriteRequest(&pReqParam);
            if(status==WRITE_SUCCESS)
            {
               err = SNMP_ERR_NOERROR;
              }
          }
       }
         break;
      case 13:
         {
            /* upsCfgBypassNotAllowed */
            s32_t *v = (s32_t *)value;
            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v <0) || (*v > 1)))
           {
              return err;
           }
           else
           {
                pReqParam.taskID=SNMP_TASK_ID;
            
                 if(*v==0)
                 {
                 	sprintf((char *)pReqParam.ctrlcommand,"%s","PDF\r");
                 }
                 else if(*v==1)
                 {
                  	sprintf((char *)pReqParam.ctrlcommand,"%s","PEF\r");
                  }
                  pReqParam.ctrlcmdSize=PEPD_CMD_SIZE;

                status=UPSInterface_InitiateWriteRequest(&pReqParam);
                 if(status==WRITE_SUCCESS)
                 {
                      err = SNMP_ERR_NOERROR;
                 }
            }
         }
         break;
      case 14:
         {
            /* upsCfgBatterylowprotect */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v <0) || (*v > 1)))
             {
                return err;
             }
             else
             {
                  pReqParam.taskID=SNMP_TASK_ID;
                   if(*v==0)
                   {
             	      sprintf((char *)pReqParam.ctrlcommand,"%s","PDT\r");
                    }
                   else if(*v==1)
                   {
                   	sprintf((char *)pReqParam.ctrlcommand,"%s","PET\r");
                   }
                    pReqParam.ctrlcmdSize=PEPD_CMD_SIZE;

                  status=UPSInterface_InitiateWriteRequest(&pReqParam);
                   if(status==WRITE_SUCCESS)
                   {
                        err = SNMP_ERR_NOERROR;
                   }
              }
         }
         break;
      case 15:
         {
            /* upsCfgP1progoutletcontrol */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v <0) || (*v > 1)))
             {
                return err;
             }
             else
             {
                  pReqParam.taskID=SNMP_TASK_ID;          
                   if(*v==0)
                   {
				     sprintf((char *)pReqParam.ctrlcommand,"%s","PDJ\r");              
                   }
                   else if(*v==1)
                   {
                     sprintf((char *)pReqParam.ctrlcommand,"%s","PEJ\r");
                   }
			        pReqParam.ctrlcmdSize=PEPD_CMD_SIZE;

                  status=UPSInterface_InitiateWriteRequest(&pReqParam);
                   if(status==WRITE_SUCCESS)
                   {
                        err = SNMP_ERR_NOERROR;
                   }
              }
         }
         break;
      case 16:
         {
            /* upsCfgP2progoutletcontrol */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v <0) || (*v > 1)))
             {
                return err;
             }
             else
             {
                  pReqParam.taskID=SNMP_TASK_ID;
                   if(*v==0)
                   {
					   sprintf((char *)pReqParam.ctrlcommand,"%s","PDK\r");
                   }
                   else if(*v==1)
                   {
                   	   sprintf((char *)pReqParam.ctrlcommand,"%s","PEK\r");
                   }
                  pReqParam.ctrlcmdSize=PEPD_CMD_SIZE;
                  status=UPSInterface_InitiateWriteRequest(&pReqParam);
                   if(status==WRITE_SUCCESS)
                   {
                        err = SNMP_ERR_NOERROR;
                   }
              }
         }
         break;
      case 17:
         {
            /* upsCfgInverterShortClear */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v <0) || (*v > 1)))
            {
               return err;
            }
            else
            {
                 pReqParam.taskID=SNMP_TASK_ID;
                  if(*v==0)
                  {
                   	sprintf((char *)pReqParam.ctrlcommand,"%s","PDI\r");   
                  }
                  else if(*v==1)
                  {
                  	sprintf((char *)pReqParam.ctrlcommand,"%s","PEI\r");  
                   }
                   pReqParam.ctrlcmdSize=PEPD_CMD_SIZE;

                 status=UPSInterface_InitiateWriteRequest(&pReqParam);
                  if(status==WRITE_SUCCESS)
                  {
                       err = SNMP_ERR_NOERROR;
                  }
             }
         }
         break;
      case 18:
         {
            /* upsCfgSitefaildetection */
            s32_t *v = (s32_t *)value;
            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v <0) || (*v > 1)))
            {
               return err;
            }
            else
            {
                pReqParam.taskID=SNMP_TASK_ID;
             
                 if(*v==0)
                 {
                 	sprintf((char *)pReqParam.ctrlcommand,"%s","PDL\r");  
                  
                 }
                 else if(*v==1)
                 {
                    sprintf((char *)pReqParam.ctrlcommand,"%s","PEL\r");  
                 }
                 pReqParam.ctrlcmdSize=CFG_SITE_FAULT;

                 status=UPSInterface_InitiateWriteRequest(&pReqParam);
                 if(status==WRITE_SUCCESS)
                 {
                      err = SNMP_ERR_NOERROR;
                 }
             }
         }
         break;
      case 19:
         {
            /* upsCfgBatNumInParallel */
            s32_t *v = (s32_t *)value;
            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v < 1) || (*v > 99)))
           {
              return err;
           }
            else
            {
                pReqParam.taskID=SNMP_TASK_ID;
                sprintf((char *)pReqParam.ctrlcommand,"%s%02d%c","BATGN" ,*v,'\r');
                pReqParam.ctrlcmdSize=BATGRPN_CMD_SIZE;
                status=UPSInterface_InitiateWriteRequest(&pReqParam);
                if(status==WRITE_SUCCESS)
                {
                   err = SNMP_ERR_NOERROR;
                }
            }
       }
       break;
      case 20:
         {
            /* upsCfgBatNumInSeries */
            s32_t *v = (s32_t *)value;
            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v >= 1) && (*v <= 20)))
            {
                err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
            }

         }
         break;
      case 21:
         {
            /* upsCfgBypassmaxvoltage */
            s32_t *v = (s32_t *)value;
            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v < 1760) || (*v > 2760)))
           {
              return err;
           }
          else
          {
                pReqParam.taskID=SNMP_TASK_ID;
                tempData=*v/10;
                sprintf((char *)pReqParam.ctrlcommand,"%s%03d%c","PHV", tempData,'\r');
                pReqParam.ctrlcmdSize=PHV_CMD_SIZE;
                status=UPSInterface_InitiateWriteRequest(&pReqParam);
                if(status==WRITE_SUCCESS)
                {

                       err = SNMP_ERR_NOERROR;
                 }
             }
         }
         break;
      case 22:
         {
            /* upsCfgBypassminvoltage */
            s32_t *v = (s32_t *)value;
            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v < 1760) || (*v > 2760)))
             {
                return err;
             }
            else
            {
                pReqParam.taskID=SNMP_TASK_ID;
                sprintf((char *)pReqParam.ctrlcommand,"%s%03d%c","PLV", *v/10,'\r');
                pReqParam.ctrlcmdSize=PLV_CMD_SIZE;
                status=UPSInterface_InitiateWriteRequest(&pReqParam);
                if(status==WRITE_SUCCESS)
                {
                     err = SNMP_ERR_NOERROR;
                  }
               }
         }
         break;
      case 23:
         {
            /* upsCfgBypassmaxfrequency */
            s32_t *v = (s32_t *)value;
            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v <510) || (*v > 700)))
            {
                err = SNMP_ERR_NOERROR;
            }
            else
            {
                pReqParam.taskID=SNMP_TASK_ID;
                sprintf((char *)pReqParam.ctrlcommand,"%s%2.1f%c","PGF", (float)(*v/10),'\r');
                pReqParam.ctrlcmdSize=PGF_CMD_SIZE;
                status=UPSInterface_InitiateWriteRequest(&pReqParam);
                if(status==WRITE_SUCCESS)
                {
                    err = SNMP_ERR_NOERROR;
                }
            }

         }
         break;
      case 24:
         {
            /* upsCfgBypassminfrequency */
            s32_t *v = (s32_t *)value;
            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v <400) || (*v >590)))
            {
               return err;
            }
            else
            {
                pReqParam.taskID=SNMP_TASK_ID;
                sprintf((char *)pReqParam.ctrlcommand,"%s%2.1f%c","PSF", (float)(*v/10),'\r');
                pReqParam.ctrlcmdSize=PSF_CMD_SIZE;
                status=UPSInterface_InitiateWriteRequest(&pReqParam);
                if(status==WRITE_SUCCESS)
                {
                    err = SNMP_ERR_NOERROR;
                }
            }

         }
         break;
      case 25:
         {
            /* upsCfgECOmaxvoltage */
            s32_t *v = (s32_t *)value;
           LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
           if (((*v < 10) || (*v > 3000)))
           {
              return err;
           }
          else
           {
              pReqParam.taskID=SNMP_TASK_ID;
              tempData=*v/10;
              sprintf((char *)pReqParam.ctrlcommand,"%s%03d%c","HEH", tempData,'\r');
              pReqParam.ctrlcmdSize=HEH_CMD_SIZE;
              status=UPSInterface_InitiateWriteRequest(&pReqParam);
              if(status==WRITE_SUCCESS)
              {
                   err = SNMP_ERR_NOERROR;
              }
            }
         }
         break;
      case 26:
         {
            /* upsCfgECOminvoltage */
            s32_t *v = (s32_t *)value;
            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v > 3000) || (*v < 10)))
             {
                return err;
             }
            else
             {
                pReqParam.taskID=SNMP_TASK_ID;
                tempData=*v/10;
                sprintf((char *)pReqParam.ctrlcommand,"%s%03d%c","HEL", tempData,'\r');
                pReqParam.ctrlcmdSize=HEL_CMD_SIZE;
                status=UPSInterface_InitiateWriteRequest(&pReqParam);
                if(status==WRITE_SUCCESS)
                {
                   err = SNMP_ERR_NOERROR;
                }
             }
           }
         break;
      case 27:
         {
            /* upsCfgFreeRunMaxFrequency */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v >= 400) && (*v <= 700)))
            {
                err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
            }
         }
         break;
      case 28:
         {
            /* upsCfgFreeRunMinFrequency */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v >= 400) && (*v <= 700)))
            {
                err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
            }
         }
         break;
      case 34:
         {
            /* upsCfgConstantPhaseAngle */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v <0) || (*v > 1)))
           {
              return err;
           }
           else
           {
               pReqParam.taskID=SNMP_TASK_ID;
                if(*v==0)
                {
                	sprintf((char *)pReqParam.ctrlcommand,"%s","PDQ\r");
                }
                else if(*v==1)
                {
               		sprintf((char *)pReqParam.ctrlcommand,"%s","PEQ\r");
                }
				
                pReqParam.ctrlcmdSize=CFG_SITE_FAULT;
                status=UPSInterface_InitiateWriteRequest(&pReqParam);
                if(status==WRITE_SUCCESS)
                {
                     err = SNMP_ERR_NOERROR;
                }
            }
         }
         break;
      case 36:
         {
            /* upsCfgOutPhaseAngle */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if ((*v == 0) || (*v == 120) || (*v == 180) || (*v == 240))
            {
                err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
            }
         }
         break;
      case 37:
         {
            /* upsCfgLimiRunOnBatMode */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v <0) || (*v > 1)))
           {
              return err;
           }
           else
           {
               pReqParam.taskID=SNMP_TASK_ID;
             
                if(*v==0)
                {
               		sprintf((char *)pReqParam.ctrlcommand,"%s","PDW\r");
                }
                else if(*v==1)
                {
                	sprintf((char *)pReqParam.ctrlcommand,"%s","PEW\r");
                 }
                 pReqParam.ctrlcmdSize=CFG_SITE_FAULT;

                status=UPSInterface_InitiateWriteRequest(&pReqParam);
                if(status==WRITE_SUCCESS)
                {
                     err = SNMP_ERR_NOERROR;
                }
            }
         }
         break;
      case 39:
         {
            /* upsCfgBatSeftCheckVolt */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v >= 2400) && (*v <= 2800)))
            {
                err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
            }
         }
         break;
      case 40:
         {
            /* upsCfgOverChargVolt */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v >= 130) && (*v <= 143)))
            {
                err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
            }
         }
         break;
      case 41:
         {
            /* upsCfgBattUnderVolt */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v >= 2000) && (*v <= 2400)))
            {
                err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
            }
         }
         break;
      case 42:
         {
            /* upsCfgBattLowVolt */

             err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
         }
         break;
      case 43:
         {
            /* upsCfgIn1VoltHLoss */

             err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
         }
         break;
      case 44:
         {
            /* upsCfgIn1VoltLLoss */

             err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
         }
         break;
      case 45:
         {
            /* upsCfgIn2VoltHLoss */

             err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
         }
         break;
      case 46:
         {
            /* upsCfgIn2VoltLLoss */

             err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
         }
         break;
      case 47:
         {
            /* upsCfgBatteryTurnOn */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v >= 0) && (*v <= 2)))
            {
                err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
            }
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upsconfig_scalars_set_test(): unknown id: %"S32_F"\n", node->oid));
         }
         break;
   }
   return err;
}
snmp_err_t upsconfig_scalars_set_value(const struct snmp_scalar_array_node_def *node, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_NOERROR;

   LWIP_UNUSED_ARG(len);
   switch (node->oid)
   {
      case 1:
         {
            /* upsCfgAlarmbypass */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            UPSDb.settingFlags.upsFlagsBits.bypassAudibleWarning=*v;		
         }
         break;
      case 2:
         {
            /* upsCfgAlarmbattery */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 3:
         {
            /* upsCfgAutoReboot */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 4:
         {
            /* upsCfgBypasswhenupsoff */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 5:
         {
            /* upsCfgBatterDDP */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 6:
         {
            /* upsCfgConvertermode */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 7:
         {
            /* upsCfgECOmode */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 8:
         {
            /* upsCfgAdvanceECOmode */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 9:
         {
            /* upsCfgGreenPowerFunction */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 10:
         {
            /* upsCfgBatteryOSC */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 11:
         {
            /* upsCfgAllowShort3times */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 12:
         {
            /* upsCfgColdstart */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 13:
         {
            /* upsCfgBypassNotAllowed */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 14:
         {
            /* upsCfgBatterylowprotect */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 15:
         {
            /* upsCfgP1progoutletcontrol */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 16:
         {
            /* upsCfgP2progoutletcontrol */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 17:
         {
            /* upsCfgInverterShortClear */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 18:
         {
            /* upsCfgSitefaildetection */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 19:
         {
            /* upsCfgBatNumInParallel */
            s32_t *v = (s32_t *)value;
            UPSDb.BatNumberInParallel=*v;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 20:
         {
            /* upsCfgBatNumInSeries */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 21:
         {
            /* upsCfgBypassmaxvoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 22:
         {
            /* upsCfgBypassminvoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 23:
         {
            /* upsCfgBypassmaxfrequency */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 24:
         {
            /* upsCfgBypassminfrequency */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 25:
         {
            /* upsCfgECOmaxvoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 26:
         {
            /* upsCfgECOminvoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 27:
         {
            /* upsCfgFreeRunMaxFrequency */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 28:
         {
            /* upsCfgFreeRunMinFrequency */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 34:
         {
            /* upsCfgConstantPhaseAngle */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 36:
         {
            /* upsCfgOutPhaseAngle */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 37:
         {
            /* upsCfgLimiRunOnBatMode */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 39:
         {
            /* upsCfgBatSeftCheckVolt */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 40:
         {
            /* upsCfgOverChargVolt */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 41:
         {
            /* upsCfgBattUnderVolt */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 42:
         {
            /* upsCfgBattLowVolt */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 43:
         {
            /* upsCfgIn1VoltHLoss */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 44:
         {
            /* upsCfgIn1VoltLLoss */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 45:
         {
            /* upsCfgIn2VoltHLoss */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 46:
         {
            /* upsCfgIn2VoltLLoss */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 47:
         {
            /* upsCfgBatteryTurnOn */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("upsconfig_scalars_set_value(): unknown id: %"S32_F"\n", node->oid));
         }
         break;
   }
   return err;
}

s16_t extend_scalars_get_value(const struct snmp_scalar_array_node_def *node, void *value)
{
   s16_t value_len;

   switch (node->oid)
   {
      case 1:
         {
            /* extendWorkTemperature */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 2:
         {
            /* extendWorkhumidity */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 3:
         {
            /* extendSmokeScope */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 4:
         {
            /* extendEMDAlarm1 */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 5:
         {
            /* extendEMDAlarm2 */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 6:
         {
            /* extendEMDAlarm3 */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 7:
         {
            /* extendEMDAlarm4 */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("extend_scalars_get_value(): unknown id: %"S32_F"\n", node->oid));
            value_len = 0;
         }
         break;
   }
   return value_len;
}

/* --- products 1.3.6.1.4.1.21111.1 ----------------------------------------------------- */
/* --- companyMIB  ----------------------------------------------------- */
#endif /* LWIP_SNMP */
