/*
Generated by LwipMibCompiler
*/

#include "lwip/apps/snmp_opts.h"
#if LWIP_SNMP

#include "upsMIB2.h"
//#include "DatabaseHandler.h"
#include "UPSInterface.h"

/* --- upsInput 1.3.6.1.2.1.33.1.3 ----------------------------------------------------- */
static const struct snmp_scalar_node UPSMIBinputlinebads_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(1, SNMP_ASN1_TYPE_COUNTER, UPSMIBinput_treenode_get_value);

static const struct snmp_scalar_node UPSMIBinputnumlines_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(2, SNMP_ASN1_TYPE_INTEGER, UPSMIBinput_treenode_get_value);

static const struct snmp_table_col_def UPSMIBinputtable_columns[] = {
  {1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsInLineIndex */ 
  {2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsInFrequency */ 
  {3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsInVoltage */ 
  {4, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsInCurrent */ 
  {5, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsInTruePower */ 
};

static const struct snmp_table_node UPSMIBinputtable = SNMP_TABLE_CREATE(3, UPSMIBinputtable_columns, UPSMIBinputtable_get_instance, UPSMIBinputtable_get_next_instance, UPSMIBinputtable_get_value, NULL, NULL);

static const struct snmp_node *const UPSMIBinput_subnodes[] = {
  &UPSMIBinputlinebads_scalar.node.node,
  &UPSMIBinputnumlines_scalar.node.node,
  &UPSMIBinputtable.node.node
};
static const struct snmp_tree_node UPSMIBinput_treenode = SNMP_CREATE_TREE_NODE(3, UPSMIBinput_subnodes);

/* --- upsOutput 1.3.6.1.2.1.33.1.4 ----------------------------------------------------- */
static const struct snmp_scalar_node UPSMIBoutputsource_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(1, SNMP_ASN1_TYPE_INTEGER, UPSMIBoutput_treenode_get_value);

static const struct snmp_scalar_node UPSMIBoutputfrequency_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(2, SNMP_ASN1_TYPE_INTEGER, UPSMIBoutput_treenode_get_value);

static const struct snmp_scalar_node UPSMIBoutputnumlines_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(3, SNMP_ASN1_TYPE_INTEGER, UPSMIBoutput_treenode_get_value);

static const struct snmp_table_col_def UPSMIBoutputtable_columns[] = {
  {1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsOutLineIndex */ 	
  {2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsOutputVoltage */ 
  {3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsOutputCurrent */ 
  {4, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsOutputPower */ 
  {5, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsOutputPercentLoad */ 
};
static const struct snmp_table_node UPSMIBoutputtable = SNMP_TABLE_CREATE(4, UPSMIBoutputtable_columns, UPSMIBoutputtable_get_instance, UPSMIBoutputtable_get_next_instance, UPSMIBoutputtable_get_value, NULL, NULL);

static const struct snmp_node *const UPSMIBoutput_subnodes[] = {
  &UPSMIBoutputsource_scalar.node.node,
  &UPSMIBoutputfrequency_scalar.node.node,
  &UPSMIBoutputnumlines_scalar.node.node,
  &UPSMIBoutputtable.node.node
};
static const struct snmp_tree_node UPSMIBoutput_treenode = SNMP_CREATE_TREE_NODE(4, UPSMIBoutput_subnodes);

/* --- upsBypass 1.3.6.1.2.1.33.1.5 ----------------------------------------------------- */
static const struct snmp_scalar_node UPSMIBbypassfrequency_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(1, SNMP_ASN1_TYPE_INTEGER, UPSMIBbypass_treenode_get_value);

static const struct snmp_scalar_node UPSMIBbypassnumlines_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(2, SNMP_ASN1_TYPE_INTEGER, UPSMIBbypass_treenode_get_value);

static const struct snmp_table_col_def UPSMIBbypasstable_columns[] = {
  {1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsByLineIndex */ 	
  {2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBypassVoltage */ 
  {3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBypassCurrent */ 
  {4, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBypassPower */ 
};
static const struct snmp_table_node UPSMIBbypasstable = SNMP_TABLE_CREATE(3, UPSMIBbypasstable_columns, UPSMIBbypasstable_get_instance, UPSMIBbypasstable_get_next_instance, UPSMIBbypasstable_get_value, NULL, NULL);

static const struct snmp_node *const UPSMIBbypass_subnodes[] = {
  &UPSMIBbypassfrequency_scalar.node.node,
  &UPSMIBbypassnumlines_scalar.node.node,
  &UPSMIBbypasstable.node.node
};
static const struct snmp_tree_node UPSMIBbypass_treenode = SNMP_CREATE_TREE_NODE(5, UPSMIBbypass_subnodes);

/* --- upsAlarm 1.3.6.1.2.1.33.1.6 ----------------------------------------------------- */
static const struct snmp_scalar_node UPSMIBalarmspresent_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(1, SNMP_ASN1_TYPE_GAUGE, UPSMIBAlarmsPresent_get_value);

static const struct snmp_table_col_def UPSMIBalarmtable_columns[] = {
	{1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /*  upsAlarmId */   
	{2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /*  upsAlarmDescr */ 
	{3, SNMP_ASN1_TYPE_TIMETICKS, SNMP_NODE_INSTANCE_READ_ONLY}, /*  upsAlarmTime */ 
};
static const struct snmp_table_node UPSMIBalarmtable = SNMP_TABLE_CREATE(2, UPSMIBalarmtable_columns, UPSMIBalarmtable_get_instance, UPSMIBalarmtable_get_next_instance, UPSMIBalarmtable_get_value, NULL, NULL);

static const struct snmp_node *const UPSMIBalarm_subnodes[] = {
  &UPSMIBalarmspresent_scalar.node.node,
  &UPSMIBalarmtable.node.node
};
static const struct snmp_tree_node UPSMIBalarm_treenode = SNMP_CREATE_TREE_NODE(6, UPSMIBalarm_subnodes);

/* --- upsObjects 1.3.6.1.2.1.33.1 ----------------------------------------------------- */
static const struct snmp_scalar_array_node_def UPSMIBident_scalars_nodes[] = {
  {1, SNMP_ASN1_TYPE_OCTET_STRING, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsIdentManufacturer */ 
  {2, SNMP_ASN1_TYPE_OCTET_STRING, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsIdentModel */ 
  {3, SNMP_ASN1_TYPE_OCTET_STRING, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsIdentUPSSoftwareVersion */ 
  {4, SNMP_ASN1_TYPE_OCTET_STRING, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsIdentAgentSoftwareVersion */ 
  {5, SNMP_ASN1_TYPE_OCTET_STRING, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsIdentName */ 
  {6, SNMP_ASN1_TYPE_OCTET_STRING, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsIdentAttachedDevices */ 
};
static const struct snmp_scalar_array_node UPSMIBident_scalars = SNMP_SCALAR_CREATE_ARRAY_NODE(1, UPSMIBident_scalars_nodes, UPSMIBident_scalars_get_value, UPSMIBident_scalars_set_test, UPSMIBident_scalars_set_value);

static const struct snmp_scalar_array_node_def UPSMIBbattery_scalars_nodes[] = {
  {1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatteryStatus */ 
  {2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsSecondsOnBattery */ 
  {3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsEstimatedMinutesRemaining */ 
  {4, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsEstimatedChargeRemaining */ 
  {5, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatteryVoltage */ 
  {6, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatteryCurrent */ 
  {7, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsBatteryTemperature */ 
};
static const struct snmp_scalar_array_node UPSMIBbattery_scalars = SNMP_SCALAR_CREATE_ARRAY_NODE(2, UPSMIBbattery_scalars_nodes, UPSMIBbattery_scalars_get_value, NULL, NULL);

static const struct snmp_scalar_array_node_def UPSMIBtest_scalars_nodes[] = {
  {1, SNMP_ASN1_TYPE_OBJECT_ID, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsTestId */
  {2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /*  upsTestSpinLock */ 
  {3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsTestResultsSummary */ 
  {4, SNMP_ASN1_TYPE_OCTET_STRING, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsTestResultsDetail */
  {5, SNMP_ASN1_TYPE_TIMETICKS, SNMP_NODE_INSTANCE_READ_WRITE}, /*  upsTestStartTime */
  {6, SNMP_ASN1_TYPE_TIMETICKS, SNMP_NODE_INSTANCE_READ_WRITE}, /*  upsTestElapsedTime */
};
static const struct snmp_scalar_array_node UPSMIBtest_scalars = SNMP_SCALAR_CREATE_ARRAY_NODE(7, UPSMIBtest_scalars_nodes, UPSMIBtest_scalars_get_value, UPSMIBtest_scalars_set_test, UPSMIBtest_scalars_set_value);

static const struct snmp_scalar_array_node_def UPSMIBcontrol_scalars_nodes[] = {
  {1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsShutdownType */ 
  {2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsShutdownAfterDelay */ 
  {3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsStartupAfterDelay */ 
  {4, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsRebootWithDuration */ 
  {5, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsAutoRestart */ 
};
static const struct snmp_scalar_array_node UPSMIBcontrol_scalars = SNMP_SCALAR_CREATE_ARRAY_NODE(8, UPSMIBcontrol_scalars_nodes, UPSMIBcontrol_scalars_get_value, UPSMIBcontrol_scalars_set_test, UPSMIBcontrol_scalars_set_value);

static const struct snmp_scalar_array_node_def UPSMIBconfig_scalars_nodes[] = {
  {1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsConfigInputVoltage */ 
  {2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsConfigInputFreq */ 
  {3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsConfigOutputVoltage */ 
  {4, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsConfigOutputFreq */ 
  {5, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsConfigOutputVA */ 
  {6, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* upsConfigOutputPower */ 
  {7, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsConfigLowBattTime */ 
  {8, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsConfigAudibleStatus */ 
  {9, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsConfigLowVoltageTransferPoint */ 
  {10, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* upsConfigHighVoltageTransferPoint */ 
};
static const struct snmp_scalar_array_node UPSMIBconfig_scalars = SNMP_SCALAR_CREATE_ARRAY_NODE(9, UPSMIBconfig_scalars_nodes, UPSMIBconfig_scalars_get_value, UPSMIBconfig_scalars_set_test, UPSMIBconfig_scalars_set_value);

static const struct snmp_node *const UPSMIBobjects_subnodes[] = {
  &UPSMIBident_scalars.node.node,
  &UPSMIBbattery_scalars.node.node,
  &UPSMIBinput_treenode.node,
  &UPSMIBoutput_treenode.node,
  &UPSMIBbypass_treenode.node,
  &UPSMIBalarm_treenode.node,
  &UPSMIBtest_scalars.node.node,
  &UPSMIBcontrol_scalars.node.node,
  &UPSMIBconfig_scalars.node.node
};
static const struct snmp_tree_node UPSMIBobjects_treenode = SNMP_CREATE_TREE_NODE(1, UPSMIBobjects_subnodes);

/* --- upsMIB  ----------------------------------------------------- */
static const struct snmp_node *const upsmib_subnodes[] = {
  &UPSMIBobjects_treenode.node
};
static const struct snmp_tree_node upsmib_root = SNMP_CREATE_TREE_NODE(33, upsmib_subnodes);
static const u32_t upsmib_base_oid[] = {1, 3, 6, 1, 2, 1, 33};
const struct snmp_mib upsmib = {upsmib_base_oid, LWIP_ARRAYSIZE(upsmib_base_oid), &upsmib_root.node};



/*
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LWIP MIB generator - preserved section begin
Code below is preserved on regeneration. Remove these comment lines to regenerate code.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*/

/* --- upsInput 1.3.6.1.2.1.33.1.3 ----------------------------------------------------- */
snmp_err_t UPSMIBinputtable_get_instance(const u32_t *column, const u32_t *row_oid, u8_t row_oid_len, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    upsInputLineIndex (Integer, OID length = 1)
   */
   snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

   if ((row_oid_len == 1) && (*column<=5))
   {
      LWIP_UNUSED_ARG(column);
      LWIP_UNUSED_ARG(row_oid);
      LWIP_UNUSED_ARG(cell_instance);
      /*
      TODO: check if 'row_oid'/'row_oid_len' params contain a valid instance oid for a row
      If so, set 'err = SNMP_ERR_NOERROR;'
      
      snmp_oid_* methods may be used for easier processing of oid
      
      In order to avoid decoding OID a second time in subsequent get_value/set_test/set_value methods,
      you may store an arbitrary value (like a pointer to target value object) in 'cell_instance->reference'/'cell_instance->reference_len'.
      But be aware that not always a subsequent method is called -> Do NOT allocate memory here and try to release it in subsequent methods!
      
      You also may replace function pointers in 'cell_instance' param for get/test/set methods which contain the default values from table definition,
      in order to provide special methods, for the currently processed cell. Changed pointers are only valid for current request.
      */
      err = SNMP_ERR_NOERROR;
   }
   return err;
}
snmp_err_t UPSMIBinputtable_get_next_instance(const u32_t *column, struct snmp_obj_id *row_oid, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    upsInputLineIndex (Integer, OID length = 1)
   */
   u32_t columnValue=*column;
   snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

   LWIP_UNUSED_ARG(column);
   LWIP_UNUSED_ARG(row_oid);
   LWIP_UNUSED_ARG(cell_instance);

	if((columnValue <5) && (row_oid->len == 1))
	{
	   columnValue+=1;
	   cell_instance->instance_oid.id[0]=1;
	   cell_instance->instance_oid.id[1]=columnValue;
	   err = SNMP_ERR_NOERROR;
	}
	else if((columnValue <5) && (row_oid->len == 0))
	{
	   cell_instance->instance_oid.id[0]=1;
	   cell_instance->instance_oid.id[1]=columnValue;
	   row_oid->len=1;
	   row_oid->id[0]=0;
	   err = SNMP_ERR_NOERROR;
	}
	return err;

}
s16_t UPSMIBinputtable_get_value(struct snmp_node_instance *cell_instance, void *value)
{
   s16_t value_len;

   switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id))
   {
      case 1:
         {
            /* upsInLineIndex */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.supportedPhase.Bytes.InputPhase;

         }
         break;   
      case 2:
         {
            /* upsInputFrequency */
			s32_t *v = (s32_t *)value;
			value_len = sizeof(s32_t);
			*v=UPSDb.InputFreq;
         }
         break;
      case 3:
         {
            /* upsInputVoltage */
			s32_t *v = (s32_t *)value;
			value_len = sizeof(s32_t);
			*v=UPSDb.InputVolt;

         }
         break;
      case 4:
         {
            /* upsInputCurrent */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
             LWIP_UNUSED_ARG(v);
         }
         break;
      case 5:
         {
            /* upsInputTruePower */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("UPSMIBinputtable_get_value(): unknown id: %"S32_F"\n", SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
            value_len = 0;
         }
         break;
   }
   return value_len;
}

s16_t UPSMIBinput_treenode_get_value(struct snmp_node_instance *instance, void *value)
{
   s16_t value_len;

   switch (instance->node->oid)
   {
      case 1:
         {
            /* upsInputLineBads */
            u32_t *v = (u32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(u32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 2:
         {
            /* upsInputNumLines */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.supportedPhase.Bytes.InputPhase;
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("UPSMIBinput_treenode_get_value(): unknown id: %"S32_F"\n", instance->node->oid));
            value_len = 0;
         }
         break;
   }
   return value_len;
}

/* --- upsOutput 1.3.6.1.2.1.33.1.4 ----------------------------------------------------- */
snmp_err_t UPSMIBoutputtable_get_instance(const u32_t *column, const u32_t *row_oid, u8_t row_oid_len, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    upsOutputLineIndex (Integer, OID length = 1)
   */
   snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

   if ((row_oid_len == 1) && (*column<=5))
   {
      LWIP_UNUSED_ARG(column);
      LWIP_UNUSED_ARG(row_oid);
      LWIP_UNUSED_ARG(cell_instance);
      /*
      TODO: check if 'row_oid'/'row_oid_len' params contain a valid instance oid for a row
      If so, set 'err = SNMP_ERR_NOERROR;'
      
      snmp_oid_* methods may be used for easier processing of oid
      
      In order to avoid decoding OID a second time in subsequent get_value/set_test/set_value methods,
      you may store an arbitrary value (like a pointer to target value object) in 'cell_instance->reference'/'cell_instance->reference_len'.
      But be aware that not always a subsequent method is called -> Do NOT allocate memory here and try to release it in subsequent methods!
      
      You also may replace function pointers in 'cell_instance' param for get/test/set methods which contain the default values from table definition,
      in order to provide special methods, for the currently processed cell. Changed pointers are only valid for current request.
      */
      err = SNMP_ERR_NOERROR;
   }
   return err;
}
snmp_err_t UPSMIBoutputtable_get_next_instance(const u32_t *column, struct snmp_obj_id *row_oid, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    upsOutputLineIndex (Integer, OID length = 1)
   */
   u32_t columnValue=*column;
   snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

   LWIP_UNUSED_ARG(column);
   LWIP_UNUSED_ARG(row_oid);
   LWIP_UNUSED_ARG(cell_instance);
   if((columnValue <5) && (row_oid->len == 1))
   {
	  columnValue+=1;
	  cell_instance->instance_oid.id[0]=1;
	  cell_instance->instance_oid.id[1]=columnValue;
	  err = SNMP_ERR_NOERROR;
   }
   else if((columnValue <5) && (row_oid->len == 0))
   {
	  cell_instance->instance_oid.id[0]=1;
	  cell_instance->instance_oid.id[1]=columnValue;
	  row_oid->len=1;
	  row_oid->id[0]=0;
	  err = SNMP_ERR_NOERROR;
   }
   return err;

}
s16_t UPSMIBoutputtable_get_value(struct snmp_node_instance *cell_instance, void *value)
{
   s16_t value_len;

   switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id))
   {
      case 1:
         {
            /* upsOutLineIndex */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
           *v=UPSDb.supportedPhase.Bytes.OutputPhase;
         }
         break;   
      case 2:
         {
            /* upsOutputVoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.OutputVolt;
         }
         break;
      case 3:
         {
            /* upsOutputCurrent */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.OutputCurr;
         }
         break;
      case 4:
         {
            /* upsOutputPower */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 5:
         {
            /* upsOutputPercentLoad */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.OutputLoadPercent;
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("UPSMIBoutputtable_get_value(): unknown id: %"S32_F"\n", SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
            value_len = 0;
         }
         break;
   }
   return value_len;
}

s16_t UPSMIBoutput_treenode_get_value(struct snmp_node_instance *instance, void *value)
{
   s16_t value_len;

   switch (instance->node->oid)
   {
      case 1:
         {
            /* upsOutputSource */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
           	if(UPSDb.UPSMode[0]=='P')//Power On Mode
            {
           	 MEMCPY(value,UPSDb.UPSMode,2);//*v=3;//Normal*v=3;//Normal
            }				
			else if(UPSDb.UPSMode[0]=='S')//Standby Mode
            {
			    MEMCPY(value,UPSDb.UPSMode,2);//*v=3;//Normal*v=1;//Other
            }		
            else if(UPSDb.UPSMode[0]=='Y')//Bypass Mode
            {
                MEMCPY(value,UPSDb.UPSMode,2);//*v=3;//Normal*v=4;//Bypass
            }	
            else if(UPSDb.UPSMode[0]=='L')//Line Mode
            {
                MEMCPY(value,UPSDb.UPSMode,2);//*v=3;//Normal*v=1;//Other
            }	
            else if(UPSDb.UPSMode[0]=='B')//Battery Mode
            {
				*v=5;//Battery Mode
            }			
            else if(UPSDb.UPSMode[0]=='T')//Battery test Mode
            {
				*v=8;//Battery test Mode
            }	
            else if(UPSDb.UPSMode[0]=='F')//Fault Mode
            {
				*v=9;//Fault Mode
            }
            else if(UPSDb.UPSMode[0]=='E')//HE/ECO Mode
            {
				*v=10;//HE/ECO Mode
            }
            else if(UPSDb.UPSMode[0]=='C')//Converter Mode
            {
				*v=8;//Converter Mode
            }
            else if(UPSDb.UPSMode[0]=='D')//Shutdown Mode
            {
				*v=1;//other
            }			
            else 
            {
				*v=2;//none
            }
         }
         break;
      case 2:
         {
            /* upsOutputFrequency */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.OutputFreq;
         }
         break;
      case 3:
         {
            /* upsOutputNumLines */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.supportedPhase.Bytes.OutputPhase;
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("UPSMIBoutput_treenode_get_value(): unknown id: %"S32_F"\n", instance->node->oid));
            value_len = 0;
         }
         break;
   }
   return value_len;
}

/* --- upsBypass 1.3.6.1.2.1.33.1.5 ----------------------------------------------------- */
snmp_err_t UPSMIBbypasstable_get_instance(const u32_t *column, const u32_t *row_oid, u8_t row_oid_len, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    upsBypassLineIndex (Integer, OID length = 1)
   */
   snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

   if ((row_oid_len == 1) && (*column<=4))
   {
      LWIP_UNUSED_ARG(column);
      LWIP_UNUSED_ARG(row_oid);
      LWIP_UNUSED_ARG(cell_instance);
      /*
      TODO: check if 'row_oid'/'row_oid_len' params contain a valid instance oid for a row
      If so, set 'err = SNMP_ERR_NOERROR;'
      
      snmp_oid_* methods may be used for easier processing of oid
      
      In order to avoid decoding OID a second time in subsequent get_value/set_test/set_value methods,
      you may store an arbitrary value (like a pointer to target value object) in 'cell_instance->reference'/'cell_instance->reference_len'.
      But be aware that not always a subsequent method is called -> Do NOT allocate memory here and try to release it in subsequent methods!
      
      You also may replace function pointers in 'cell_instance' param for get/test/set methods which contain the default values from table definition,
      in order to provide special methods, for the currently processed cell. Changed pointers are only valid for current request.
      */
      err = SNMP_ERR_NOERROR;
   }
   return err;
}
snmp_err_t UPSMIBbypasstable_get_next_instance(const u32_t *column, struct snmp_obj_id *row_oid, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    upsBypassLineIndex (Integer, OID length = 1)
   */
   u32_t columnValue=*column;
   snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

   LWIP_UNUSED_ARG(column);
   LWIP_UNUSED_ARG(row_oid);
   LWIP_UNUSED_ARG(cell_instance);
   
   if((columnValue <4) && (row_oid->len == 1))
   {
	  columnValue+=1;
	  cell_instance->instance_oid.id[0]=1;
	  cell_instance->instance_oid.id[1]=columnValue;
	  err = SNMP_ERR_NOERROR;
   }
   else if((columnValue <4) && (row_oid->len == 0))
   {
	  cell_instance->instance_oid.id[0]=1;
	  cell_instance->instance_oid.id[1]=columnValue;
	  row_oid->len=1;
	  row_oid->id[0]=0;
	  err = SNMP_ERR_NOERROR;
   }
   return err;

}
s16_t UPSMIBbypasstable_get_value(struct snmp_node_instance *cell_instance, void *value)
{
   s16_t value_len;

   switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id))
   {
      case 1:
         {
            /* upsByLineIndex */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.supportedPhase.Bytes.OutputPhase;
         }
         break;   
      case 2:
         {
            /* upsBypassVoltage */
			 s32_t *v = (s32_t *)value;
			
			 /* TODO: put requested value to '*v' here */
			 value_len = sizeof(s32_t);
			*v=UPSDb.OutputVolt;
         }
         break;
      case 3:
         {
            /* upsBypassCurrent */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.OutputCurr;
         }
         break;
      case 4:
         {
            /* upsBypassPower */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.OutputVolt * UPSDb.OutputCurr;
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("UPSMIBbypasstable_get_value(): unknown id: %"S32_F"\n", SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
            value_len = 0;
         }
         break;
   }
   return value_len;
}

s16_t UPSMIBbypass_treenode_get_value(struct snmp_node_instance *instance, void *value)
{
   s16_t value_len;

   switch (instance->node->oid)
   {
      case 1:
         {
            /* upsBypassFrequency */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.OutputFreq;
         }
         break;
      case 2:
         {
            /* upsBypassNumLines */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.supportedPhase.Bytes.OutputPhase;
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("UPSMIBbypass_treenode_get_value(): unknown id: %"S32_F"\n", instance->node->oid));
            value_len = 0;
         }
         break;
   }
   return value_len;
}

/* --- upsAlarm 1.3.6.1.2.1.33.1.6 ----------------------------------------------------- */
s16_t UPSMIBAlarmsPresent_get_value(struct snmp_node_instance *instance, void *value)
{
	s16_t value_len;
	u32_t *v = (u32_t *)value;
	
	LWIP_UNUSED_ARG(instance);
	/* TODO: put requested value to '*v' here */
	value_len = sizeof(u32_t);
	LWIP_UNUSED_ARG(v);
	*v=0;
	return value_len;

}

snmp_err_t UPSMIBalarmtable_get_instance(const u32_t *column, const u32_t *row_oid, u8_t row_oid_len, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    upsAlarmId (Integer, OID length = 1)
   */
   snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

    if ((row_oid_len == 1) && (*column<=3))
   {
      LWIP_UNUSED_ARG(column);
      LWIP_UNUSED_ARG(row_oid);
      LWIP_UNUSED_ARG(cell_instance);
      /*
      TODO: check if 'row_oid'/'row_oid_len' params contain a valid instance oid for a row
      If so, set 'err = SNMP_ERR_NOERROR;'
      
      snmp_oid_* methods may be used for easier processing of oid
      
      In order to avoid decoding OID a second time in subsequent get_value/set_test/set_value methods,
      you may store an arbitrary value (like a pointer to target value object) in 'cell_instance->reference'/'cell_instance->reference_len'.
      But be aware that not always a subsequent method is called -> Do NOT allocate memory here and try to release it in subsequent methods!
      
      You also may replace function pointers in 'cell_instance' param for get/test/set methods which contain the default values from table definition,
      in order to provide special methods, for the currently processed cell. Changed pointers are only valid for current request.
      */
      err = SNMP_ERR_NOERROR;
   }
   return err;
}
snmp_err_t UPSMIBalarmtable_get_next_instance(const u32_t *column, struct snmp_obj_id *row_oid, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    upsAlarmId (Integer, OID length = 1)
   */
   u32_t columnValue=*column;
   snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

   LWIP_UNUSED_ARG(column);
   LWIP_UNUSED_ARG(row_oid);
   LWIP_UNUSED_ARG(cell_instance);

   if((columnValue <3) && (row_oid->len == 1))
   {
	  columnValue+=1;
	  cell_instance->instance_oid.id[0]=1;
	  cell_instance->instance_oid.id[1]=columnValue;
	  err = SNMP_ERR_NOERROR;
   }
   else if((columnValue <3) && (row_oid->len == 0))
   {
	  cell_instance->instance_oid.id[0]=1;
	  cell_instance->instance_oid.id[1]=columnValue;
	  row_oid->len=1;
	  row_oid->id[0]=0;
	  err = SNMP_ERR_NOERROR;
   }
   return err;

}

s16_t UPSMIBalarmtable_get_value(struct snmp_node_instance *instance, void *value)
{
   s16_t value_len;

   switch (SNMP_TABLE_GET_COLUMN_FROM_OID(instance->instance_oid.id))
   {
      case 1:
         {
            /* upsAlarmId */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=0;
         }
         break;
      case 2:
         {
            /* upsAlarmDescr */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=0;
         }
         break;
      case 3:
         {
            /* upsAlarmTime */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=0;
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("UPSMIBAlarmsPresent_get_value(): unknown id: %"S32_F"\n", SNMP_TABLE_GET_COLUMN_FROM_OID(instance->instance_oid.id)));
            value_len = 0;
         }
         break;
   }
   return value_len;
}

/* --- upsObjects 1.3.6.1.2.1.33.1 ----------------------------------------------------- */
s16_t UPSMIBident_scalars_get_value(const struct snmp_scalar_array_node_def *node, void *value)
{
   s16_t value_len;

   switch (node->oid)
   {
      case 1:
         {
            /* upsIdentManufacturer */
          //  u8_t *v = (u8_t *)value;

            /* TODO: take care that value with variable length fits into buffer: (value_len <= SNMP_MAX_VALUE_SIZE) */
            /* TODO: take care of len restrictions defined in MIB: ((value_len >= 0) && (value_len <= 31)) */
            /* TODO: put requested value to '*v' here */
            value_len = strlen((const char*)UPSDb.UPSManufacturer);
            MEMCPY(value,UPSDb.UPSManufacturer,value_len);
         }
         break;
      case 2:
         {
            /* upsIdentModel */
          //  u8_t *v = (u8_t *)value;

            /* TODO: take care that value with variable length fits into buffer: (value_len <= SNMP_MAX_VALUE_SIZE) */
            /* TODO: take care of len restrictions defined in MIB: ((value_len >= 0) && (value_len <= 63)) */
            /* TODO: put requested value to '*v' here */
            value_len = strlen((const char*)UPSDb.UPSModel);
            MEMCPY(value,UPSDb.UPSModel,value_len);
         }
         break;
      case 3:
         {
            /* upsIdentUPSSoftwareVersion */
           // u8_t *v = (u8_t *)value;

            /* TODO: take care that value with variable length fits into buffer: (value_len <= SNMP_MAX_VALUE_SIZE) */
            /* TODO: take care of len restrictions defined in MIB: ((value_len >= 0) && (value_len <= 63)) */
            /* TODO: put requested value to '*v' here */
            value_len = LWIP_ARRAYSIZE(UPSDb.UPSCPUFwVersion);
            MEMCPY(value,UPSDb.UPSCPUFwVersion,value_len);


         }
         break;
      case 4:
         {
            /* upsIdentAgentSoftwareVersion */
            u8_t *v = (u8_t *)value;

            /* TODO: take care that value with variable length fits into buffer: (value_len <= SNMP_MAX_VALUE_SIZE) */
            /* TODO: take care of len restrictions defined in MIB: ((value_len >= 0) && (value_len <= 63)) */
            /* TODO: put requested value to '*v' here */
			 value_len = 0;
			 LWIP_UNUSED_ARG(v);
         }
         break;
      case 5:
         {
            /* upsIdentName */
            //u8_t *v = (u8_t *)value;

            /* TODO: take care that value with variable length fits into buffer: (value_len <= SNMP_MAX_VALUE_SIZE) */
            /* TODO: take care of len restrictions defined in MIB: ((value_len >= 0) && (value_len <= 63)) */
            /* TODO: put requested value to '*v' here */
            value_len = strlen("SNMP Card");
            MEMCPY(value,"SNMP Card",value_len);
         }
         break;
      case 6:
         {
            /* upsIdentAttachedDevices */
            u8_t *v = (u8_t *)value;

            /* TODO: take care that value with variable length fits into buffer: (value_len <= SNMP_MAX_VALUE_SIZE) */
            /* TODO: take care of len restrictions defined in MIB: ((value_len >= 0) && (value_len <= 63)) */
            /* TODO: put requested value to '*v' here */
            value_len = 0;
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("UPSMIBident_scalars_get_value(): unknown id: %"S32_F"\n", node->oid));
            value_len = 0;
         }
         break;
   }
   return value_len;
}
snmp_err_t UPSMIBident_scalars_set_test(const struct snmp_scalar_array_node_def *node, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_WRONGVALUE;

   switch (node->oid)
   {
      case 5:
         {
            /* upsIdentName */
            u8_t *v = (u8_t *)value;

            if (((len >= 0) && (len <= 63)))
            {
                err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
            }
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 6:
         {
            /* upsIdentAttachedDevices */
            u8_t *v = (u8_t *)value;

            if (((len >= 0) && (len <= 63)))
            {
                err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
            }
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("UPSMIBident_scalars_set_test(): unknown id: %"S32_F"\n", node->oid));
         }
         break;
   }
   return err;
}
snmp_err_t UPSMIBident_scalars_set_value(const struct snmp_scalar_array_node_def *node, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_NOERROR;

   LWIP_UNUSED_ARG(len);
   switch (node->oid)
   {
      case 5:
         {
            /* upsIdentName */
            u8_t *v = (u8_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 6:
         {
            /* upsIdentAttachedDevices */
            u8_t *v = (u8_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("UPSMIBident_scalars_set_value(): unknown id: %"S32_F"\n", node->oid));
         }
         break;
   }
   return err;
}

s16_t UPSMIBbattery_scalars_get_value(const struct snmp_scalar_array_node_def *node, void *value)
{
   s16_t value_len;

   switch (node->oid)
   {
      case 1:
		 {
			 /* upsBatStatus */
			 s32_t *v = (s32_t *)value;
	 
			 /* TODO: put requested value to '*v' here */
			 value_len = sizeof(s32_t);
			 if(UPSDb.upsStatus.Bits.batTestOK==1)
			 {
				 *v=2;// Battery Normal
			 }				 
			 else if(UPSDb.warningFlags.Bits.BattLow==1)
			 {
				 *v=3;// Battery Low
			 }		 
			 else if(UPSDb.warningFlags.Bits.BatteryOpen==1)
			 {
				 *v=4;// Battery Depleted
			 }
	 
			 else if(UPSDb.UPSMode[0]=='B')
			 {
				 *v=5;// Battery discharging
			 }	 
			 else if(UPSDb.warningFlags.Bits.BatteryOpen==1)
			 {
				 *v=6;// Battery Failed
			 }			 
			 else if(UPSDb.warningFlags.Bits.BatteryReplace==1)
			 {
				 *v=7;// Battery Replace
			 }	 
			 else if(UPSDb.upsStatus.Bits.battSilence==1)
			 {
				 *v=8;// Battery Silense
			 }
			 else 
			 {
				 *v=1;// Unknown
			 }				 
		  }
         break;
      case 2:
         {
            /* upsSecondsOnBattery */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 3:
         {
            /* upsEstimatedMinutesRemaining */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            *v=UPSDb.BattRemainTime;
         }
         break;
      case 4:
         {
            /* upsEstimatedChargeRemaining */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 5:
         {
            /* upsBatteryVoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
             *v=UPSDb.BattVolt;

         }
         break;
      case 6:
         {
            /* upsBatteryCurrent */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 7:
         {
            /* upsBatteryTemperature */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
             LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("UPSMIBbattery_scalars_get_value(): unknown id: %"S32_F"\n", node->oid));
            value_len = 0;
         }
         break;
   }
   return value_len;
}

s16_t UPSMIBtest_scalars_get_value(const struct snmp_scalar_array_node_def *node, void *value)
{
   s16_t value_len;

   switch (node->oid)
   {
      case 1:
         {
            /* upsTestId */
            u32_t *v = (u32_t *)value;

            /* TODO: take care that value with variable length fits into buffer: (value_len <= SNMP_MAX_VALUE_SIZE) */
            /* TODO: put requested value to '*v' here. 'v' has to be interpreted as u32_t[] */

            value_len = 0; // TODO: return real value length here (should be 'numOfElements * sizeof(u32_t)')
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 2:
         {
            /* upsTestSpinLock */
            u32_t *v = (u32_t *)value;

            /* TODO: take care that value with variable length fits into buffer: (value_len <= SNMP_MAX_VALUE_SIZE) */
            /* TODO: put requested value to '*v' here. 'v' has to be interpreted as u32_t[] */

            value_len = 0; // TODO: return real value length here (should be 'numOfElements * sizeof(u32_t)')
            LWIP_UNUSED_ARG(v);
         }
         break;	  
      case 3:
         {
            /* upsTestResultsSummary */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
           	if(UPSDb.upsStatus.Bits.batTestOK==1)
            {
				*v=1;// passed
            }				
			else if(UPSDb.upsStatus.Bits.battTestFail==1)
            {
				*v=3;// failed
            }
			else
            {
				*v=6;// not initiated
            }
         }
         break;
      case 4:
         {
            /* upsTestResultsDetail */
            u8_t *v = (u8_t *)value;

            /* TODO: take care that value with variable length fits into buffer: (value_len <= SNMP_MAX_VALUE_SIZE) */
            /* TODO: take care of len restrictions defined in MIB: ((value_len >= 0) && (value_len <= 255)) */
            /* TODO: put requested value to '*v' here */
            value_len = 0;
            LWIP_UNUSED_ARG(v);
         }
      case 5:
         {
            /* upsTestStartTime */
            u8_t *v = (u8_t *)value;

            /* TODO: take care that value with variable length fits into buffer: (value_len <= SNMP_MAX_VALUE_SIZE) */
            /* TODO: take care of len restrictions defined in MIB: ((value_len >= 0) && (value_len <= 255)) */
            /* TODO: put requested value to '*v' here */
            value_len = 0;
            LWIP_UNUSED_ARG(v);
         }
      case 6:
         {
            /* upsTestElapsedTime */
            u8_t *v = (u8_t *)value;

            /* TODO: take care that value with variable length fits into buffer: (value_len <= SNMP_MAX_VALUE_SIZE) */
            /* TODO: take care of len restrictions defined in MIB: ((value_len >= 0) && (value_len <= 255)) */
            /* TODO: put requested value to '*v' here */
            value_len = 0;
            LWIP_UNUSED_ARG(v);
         }	  
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("UPSMIBtest_scalars_get_value(): unknown id: %"S32_F"\n", node->oid));
            value_len = 0;
         }
         break;
   }
   return value_len;
}
snmp_err_t UPSMIBtest_scalars_set_test(const struct snmp_scalar_array_node_def *node, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_WRONGVALUE;

   LWIP_UNUSED_ARG(value);
   LWIP_UNUSED_ARG(len);
   switch (node->oid)
   {
      case 1:
         {
            /* upsTestId */

             err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("UPSMIBtest_scalars_set_test(): unknown id: %"S32_F"\n", node->oid));
         }
         break;
   }
   return err;
}
snmp_err_t UPSMIBtest_scalars_set_value(const struct snmp_scalar_array_node_def *node, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_NOERROR;

   switch (node->oid)
   {
      case 1:
         {
            /* upsTestId */
            u32_t *v = (u32_t *)value;
            u8_t v_len = len / sizeof(u32_t);

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v_len);
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("UPSMIBtest_scalars_set_value(): unknown id: %"S32_F"\n", node->oid));
         }
         break;
   }
   return err;
}

s16_t UPSMIBcontrol_scalars_get_value(const struct snmp_scalar_array_node_def *node, void *value)
{
   s16_t value_len;

   switch (node->oid)
   {
      case 1:
         {
            /* upsShutdownType */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 2:
         {
            /* upsShutdownAfterDelay */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 3:
         {
            /* upsStartupAfterDelay */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 4:
         {
            /* upsRebootWithDuration */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 5:
         {
            /* upsAutoRestart */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("UPSMIBcontrol_scalars_get_value(): unknown id: %"S32_F"\n", node->oid));
            value_len = 0;
         }
         break;
   }
   return value_len;
}
snmp_err_t UPSMIBcontrol_scalars_set_test(const struct snmp_scalar_array_node_def *node, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_WRONGVALUE;
   char text_string[10] = {0};
   UPS_WRITE_REQUEST pReqParam;
   uint8_t status=WRITE_SUCCESS;
   uint32_t tempData=0;
   
   switch (node->oid)
   {
      case 1:
         {
            /* upsShutdownType */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v >= 1) && (*v <= 2)))
            {
                err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
            }
         }
         break;
      case 2:
         {
            /* upsShutdownAfterDelay */
             s32_t *v = (s32_t *)value;
             LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));

             if (((*v < -2) || (*v > 600))) //if (((*v < -2) || (*v > 2147483648)))
             {
                return err;
             }
             else
             {
                 pReqParam.taskID=SNMP_TASK_ID;
                 tempData=*v;
                 if(*v==-2)
                 {
                    sprintf((char *)pReqParam.ctrlcommand,"%s","CS\r");
                    pReqParam.ctrlcmdSize=CS_CMD_SIZE;
                 }
                 else if(*v!=-1)
                 {
                     UPSDb.BattRemainTime=*v;
                     sprintf((char *)pReqParam.ctrlcommand,"%c%d%c",'S',*v,'\r');
                     pReqParam.ctrlcmdSize=SN_CMD_SIZE;
				 }	 
	             status=UPSInterface_InitiateWriteRequest(&pReqParam);
	             if(status==WRITE_SUCCESS)
	             {
	                 err = SNMP_ERR_NOERROR;
	             }
                 
             }
          }
         break;
      case 3:
         {
            /* upsStartupAfterDelay */
            s32_t *v = (s32_t *)value;
            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
           if (((*v > 9999) ||(*v < 1) ))         //if (((*v >= -2) && (*v <= 2147483648)))
           {
               return err;
           }
           else
           {
               pReqParam.taskID=SNMP_TASK_ID;
               sprintf((char *)pReqParam.ctrlcommand,"%c%02d%c%02d%c",'S',UPSDb.BattRemainTime,'R',*v,'\r');
               pReqParam.ctrlcmdSize=SNR_CMD_SIZE;
               status=UPSInterface_InitiateWriteRequest(&pReqParam);
               if(status==WRITE_SUCCESS)
               {
                  err = SNMP_ERR_NOERROR;
               }
            }
         }
         break;
      case 4:
         {
            /* upsRebootWithDuration */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v >= -1) && (*v <= 300)))
            {
                err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
            }
         }
         break;
      case 5:
         {
            /* upsAutoRestart */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v < 1) || (*v > 2)))
            {
                return err;
            }
            else
            {
                pReqParam.taskID=SNMP_TASK_ID;
				
                if(*v==1)
                {
                    sprintf((char *)pReqParam.ctrlcommand,"%s","PER\r");
                }
                else if(*v==2)
                {
                    sprintf((char *)pReqParam.ctrlcommand,"%s","PER\r");
                }
                pReqParam.ctrlcmdSize=PEPD_CMD_SIZE;
                status=UPSInterface_InitiateWriteRequest(&pReqParam);
                if(status==WRITE_SUCCESS)
                {
                    err = SNMP_ERR_NOERROR;
                }
            }
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("UPSMIBcontrol_scalars_set_test(): unknown id: %"S32_F"\n", node->oid));
         }
         break;
   }
   return err;
}
snmp_err_t UPSMIBcontrol_scalars_set_value(const struct snmp_scalar_array_node_def *node, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_NOERROR;

   LWIP_UNUSED_ARG(len);
   switch (node->oid)
   {
      case 1:
         {
            /* upsShutdownType */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 2:
         {
            /* upsShutdownAfterDelay */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 3:
         {
            /* upsStartupAfterDelay */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 4:
         {
            /* upsRebootWithDuration */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 5:
         {
            /* upsAutoRestart */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("UPSMIBcontrol_scalars_set_value(): unknown id: %"S32_F"\n", node->oid));
         }
         break;
   }
   return err;
}

s16_t UPSMIBconfig_scalars_get_value(const struct snmp_scalar_array_node_def *node, void *value)
{
   s16_t value_len;

   switch (node->oid)
   {
      case 1:
         {
            /* UPSMIBConfigInputVoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 2:
         {
            /* upsConfigInputFreq */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 3:
         {
            /* upsConfigOutputVoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 4:
         {
            /* upsConfigOutputFreq */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 5:
         {
            /* upsConfigOutputVA */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 6:
         {
            /* upsConfigOutputPower */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 7:
         {
            /* upsConfigLowBattTime */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 8:
         {
            /* upsConfigAudibleStatus */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 9:
         {
            /* upsConfigLowVoltageTransferPoint */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 10:
         {
            /* upsConfigHighVoltageTransferPoint */
            s32_t *v = (s32_t *)value;

            /* TODO: put requested value to '*v' here */
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("UPSMIBconfig_scalars_get_value(): unknown id: %"S32_F"\n", node->oid));
            value_len = 0;
         }
         break;
   }
   return value_len;
}
snmp_err_t UPSMIBconfig_scalars_set_test(const struct snmp_scalar_array_node_def *node, u16_t len, void *value)
{
      snmp_err_t err = SNMP_ERR_WRONGVALUE;
      UPS_WRITE_REQUEST pReqParam;
      uint8_t status=WRITE_SUCCESS;
      switch (node->oid)
      {
         case 1:
            {
               /* upsConfigInputVoltage */

              err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
            }
            break;
         case 2:
            {
               /* upsConfigInputFreq */

                err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
            }
            break;
      case 3:
         {
            /* upsConfigOutputVoltage */

             err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
         }
         break;
      case 4:
         {
            /* upsConfigOutputFreq */

             err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
         }
         break;
      case 7:
         {
            /* upsConfigLowBattTime */

             err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
         }
         break;
      case 8:
         {
            /* upsConfigAudibleStatus */
            s32_t *v = (s32_t *)value;
           LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
           if (((*v < 1) || (*v > 3)))
            {
               return err;
            }
           else
           {
                pReqParam.taskID=SNMP_TASK_ID;
                if(*v==1)
                 {
                	sprintf((char *)pReqParam.ctrlcommand,"%s","PDA\r");
                    pReqParam.ctrlcmdSize=PEPD_CMD_SIZE;
               }
                else if(*v==2)
                {
                    sprintf((char *)pReqParam.ctrlcommand,"%s","PEA\r");
                    pReqParam.ctrlcmdSize=PEPD_CMD_SIZE;
                }
                else if(*v==3)
                {
                    sprintf((char *)pReqParam.ctrlcommand,"%s","BZOFF\r");
                    pReqParam.ctrlcmdSize=BZOFF_CMD_SIZE;
                 }
                status=UPSInterface_InitiateWriteRequest(&pReqParam);
                if(status==WRITE_SUCCESS)
                {
                   err = SNMP_ERR_NOERROR;
                }
         }
         }
         break;
      case 9:
         {
            /* upsConfigLowVoltageTransferPoint */

             err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
         }
         break;
      case 10:
         {
            /* upsConfigHighVoltageTransferPoint */

             err = SNMP_ERR_NOCREATION;//err = SNMP_ERR_NOERROR;
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("UPSMIBconfig_scalars_set_test(): unknown id: %"S32_F"\n", node->oid));
         }
         break;
   }
   return err;
}
snmp_err_t UPSMIBconfig_scalars_set_value(const struct snmp_scalar_array_node_def *node, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_NOERROR;

   LWIP_UNUSED_ARG(len);
   switch (node->oid)
   {
      case 1:
         {
            /* upsConfigInputVoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 2:
         {
            /* upsConfigInputFreq */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 3:
         {
            /* upsConfigOutputVoltage */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 4:
         {
            /* upsConfigOutputFreq */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 7:
         {
            /* upsConfigLowBattTime */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 8:
         {
            /* upsConfigAudibleStatus */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 9:
         {
            /* upsConfigLowVoltageTransferPoint */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 10:
         {
            /* upsConfigHighVoltageTransferPoint */
            s32_t *v = (s32_t *)value;

            /* TODO: store new value contained in '*v' here */
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("UPSMIBconfig_scalars_set_value(): unknown id: %"S32_F"\n", node->oid));
         }
         break;
   }
   return err;
}

/* --- upsMIB  ----------------------------------------------------- */
#endif /* LWIP_SNMP */


